import { types as rtypes } from "@algo-builder/runtime";
import { types as wtypes } from "@algo-builder/web";
import type { Account, LogicSigAccount, modelsv2, Transaction } from "algosdk";
import * as algosdk from "algosdk";
import { txWriter } from "../internal/tx-log-writer";
import { AlgoOperator } from "../lib/algo-operator";
import type { AppCache, ASCCache, CheckpointFunctions, CheckpointRepo, ConfirmedTxInfo, Deployer, FundASCFlags, LogicSig, LsigInfo, RuntimeEnv, SCParams } from "../types";
import { DeployerConfig } from "./deployer_cfg";
declare class DeployerBasicMode {
    protected readonly runtimeEnv: RuntimeEnv;
    protected readonly cpData: CheckpointRepo;
    protected readonly loadedAsaDefs: wtypes.ASADefs;
    protected readonly algoOp: AlgoOperator;
    protected readonly txWriter: txWriter;
    readonly accounts: rtypes.Account[];
    readonly accountsByName: rtypes.AccountMap;
    readonly indexerClient: algosdk.Indexer | undefined;
    checkpoint: CheckpointFunctions;
    constructor(deployerCfg: DeployerConfig);
    protected get networkName(): string;
    /**
     * Queries ASA Info from asset name
     * @param name asset name
     */
    getASAInfo(name: string): rtypes.ASAInfo;
    private _getAccount;
    /**
     * Returns asset definition for given name
     * @param name Asset name
     * @param asaParams Asa parameters if user wants to override existing asa definition
     */
    getASADef(name: string, asaParams?: Partial<wtypes.ASADef>): wtypes.ASADef;
    /**
     * Returns checkpoint metadata
     * @param key key for the map
     */
    getCheckpointKV(key: string): string | undefined;
    isDefined(name: string): boolean;
    get asa(): Map<string, rtypes.ASAInfo>;
    get algodClient(): algosdk.Algodv2;
    waitForConfirmation(txId: string): Promise<ConfirmedTxInfo>;
    /**
     * Queries blockchain using algodv2 for asset information by index
     * @param assetIndex asset index
     * @returns asset info from network
     */
    getAssetByID(assetIndex: number | bigint): Promise<modelsv2.Asset>;
    log(msg: string, obj: any): void;
    /**
     * Loads deployed Asset Definition from checkpoint.
     * NOTE: This function returns "deployed" ASADef, as immutable properties
     * of asaDef could be updated during tx execution (eg. update asset clawback)
     * @param asaName asset name in asa.yaml
     */
    loadASADef(asaName: string): wtypes.ASADef | undefined;
    /**
     * Loads stateful smart contract info from checkpoint
     * @param appName name of the app (defined by user during deployment)
     */
    getApp(appName: string): rtypes.AppInfo;
    /**
     * Loads logic signature object (contract or delegated) from checkpoint (by lsig name).
     * Panics if the lsig doesn't exists.
     * @param lsigName filename or lsigName (defined by user during mkContractLsig/mkDelegatedLsig)
     */
    getLsig(lsigName: string): LogicSigAccount;
    /**
     * Loads logic signature for contract mode
     * @param name ASC name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    loadLogicByFile(name: string, scTmplParams?: SCParams): Promise<LogicSigAccount>;
    /**
     * Loads logic signature from cache for contract mode. This helps user to avoid
     * passing templaste parameters always during loading logic signature.
     * @param name ASC name
     * @returns loaded logic signature from artifacts/cache/<file_name>.teal.yaml
     * @deprecated this function will be removed in the next release. Use mkContractLsig to
     * store lsig info in checkpoint (against lsigName), and query it in scripts using
     * getLsig
     */
    loadLogicFromCache(name: string): Promise<LogicSigAccount>;
    /**
     * Alias to `this.compileASC` with last two parameters being swapped.
     * @deprecated this function will be removed in the next release.
     */
    ensureCompiled(name: string, force?: boolean, scTmplParams?: SCParams): Promise<ASCCache>;
    /**
     * Returns ASCCache (with compiled code)
     * @param name: Smart Contract filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param force: if force is true file will be compiled for sure, even if it's checkpoint exist
     */
    compileASC(name: string, scTmplParams?: SCParams, force?: boolean): Promise<ASCCache>;
    /**
     * Return application in bytes source format
     * @param appName app name
     * @param source
     * @param scTmplParams
     * @returns application in bytes format
     */
    compileApplication(appName: string, source: wtypes.SmartContract, scTmplParams?: SCParams): Promise<wtypes.SourceCompiled>;
    /**
     * Returns cached program (from artifacts/cache) `ASCCache` object by app/lsig name.
     * @param name App/Lsig name used during deployment
     */
    getDeployedASC(name: string): Promise<ASCCache | AppCache | undefined>;
    /**
     * Loads multisigned logic signature account from .lsig or .blsig file
     * @param name filename
     * @returns multi signed logic signature from assets/<file_name>.(b)lsig
     */
    loadMultiSig(name: string): Promise<LogicSig>;
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    sendAndWait(rawTxns: Uint8Array | Uint8Array[]): Promise<ConfirmedTxInfo>;
    /**
     * Opt-In to ASA for a single account. The opt-in transaction is
     * signed by account secret key
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param accountName
     * @param flags Transaction flags
     */
    optInAccountToASA(asa: string, accountName: string, flags: wtypes.TxParams): Promise<void>;
    /**
     * Description: Opt-In to ASA for a contract account (represented by logic signture).
     * The opt-in transaction is signed by the logic signature
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param lsig logic signature
     * @param flags Transaction flags
     */
    optInLsigToASA(asa: string, lsig: LogicSigAccount, flags: wtypes.TxParams): Promise<void>;
    /**
     * Opt-In to stateful smart contract (SSC) for a single account
     * signed by account secret key
     * @param sender sender account
     * @param appID application index
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInAccountToApp(sender: rtypes.Account, appID: number, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInLsigToApp(appID: number, lsig: LogicSigAccount, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    /**
     * Asserts ASA is defined in a checkpoint by asset id / string,
     * First: search for ASAInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param asset asset index or asset name
     */
    private assertASAExist;
    /**
     * Asserts App is defined in a checkpoint by app id.
     * First: search for AppInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param appID Application index
     */
    private assertAppExist;
    /**
     * Group transactions into asa and app, check for cp deletion
     * @param txn Transaction execution parameter
     */
    private _assertCpNotDeleted;
    /**
     * Checks if checkpoint is deleted for a particular transaction
     * if checkpoint exist and is marked as deleted,
     * throw error(except for opt-out transactions), else pass
     * @param execParams Transaction execution parameters
     */
    assertCPNotDeleted(execParams: wtypes.ExecParams | wtypes.ExecParams[]): void;
    /**
     * Throws error if application info is not present in CP
     * @param key key against which app information is stored in checkpoint
     */
    assertAppExistsInCP(key: string): rtypes.AppInfo;
    /**
     * Return receipts for each transaction in group txn
     * @param txns list transaction in group
     * @returns confirmed tx info of group
     */
    getReceiptTxns(txns: Transaction[]): Promise<ConfirmedTxInfo[]>;
}
/**
 * This class is what user interacts with in deploy task
 */
export declare class DeployerDeployMode extends DeployerBasicMode implements Deployer {
    get isDeployMode(): boolean;
    addCheckpointKV(key: string, value: string): void;
    /**
     * Asserts if asset is not already present in checkpoint
     * @param name Asset name
     */
    assertNoAsset(name: string): void;
    /**
     * Asserts if lsig is not already present in checkpoint
     * @param lsigName lsig name
     */
    assertNoLsig(lsigName: string): void;
    /**
     * Asserts if app is not already present in checkpoint
     * @param appName app name
     */
    assertNoApp(appName: string): void;
    /**
     * Persist checkpoint till current call.
     */
    persistCP(): void;
    /**
     * Register ASA Info in checkpoints
     */
    registerASAInfo(asaName: string, asaInfo: rtypes.ASAInfo): void;
    /**
     * Register SSC Info in checkpoints
     */
    registerSSCInfo(sscName: string, sscInfo: rtypes.AppInfo): void;
    /**
     * Log transaction with message using txwriter
     */
    logTx(message: string, txConfirmation: ConfirmedTxInfo): void;
    /**
     * Creates and deploys ASA using asa.yaml.
     * @name  ASA name - deployer will search for the ASA in the /assets/asa.yaml file
     * @flags  deployment flags
     */
    deployASA(name: string, flags: rtypes.ASADeploymentFlags, asaParams?: Partial<wtypes.ASADef>): Promise<rtypes.ASAInfo>;
    /**
     * Creates and deploys ASA without using asa.yaml.
     * @name ASA name
     * @asaDef ASA definitions
     * @flags deployment flags
     */
    deployASADef(name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    /**
     * This function will send Algos to ASC account in "Contract Mode"
     * @param fileName     - ASC filename
     * @param flags    - Deployments flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    fundLsigByFile(fileName: string, flags: FundASCFlags, payFlags: wtypes.TxParams, scTmplParams?: SCParams): Promise<void>;
    /**
     * This function will send Algos to ASC account in "Contract Mode". Takes lsig name
     * as input
     * @param lsigName - name of the smart signature (defined by user during mkContractLsig/mkDelegatedLsig)
     * @param flags    - Deployments flags (as per SPEC)
     * @param payFlags - as per SPEC
     */
    fundLsig(lsigName: string, flags: FundASCFlags, payFlags: wtypes.TxParams): Promise<void>;
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * @param name: Logic Signature filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param signer: Signer Account which will sign the smart
     * contract(optional in case of contract account)
     * @param lsigName name of lsig (if passed, checkpoint info will be stored against this name)
     */
    _mkLsig(fileName: string, scTmplParams?: SCParams, signer?: rtypes.Account, lsigName?: string): Promise<LsigInfo>;
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * https://developer.algorand.org/docs/features/asc1/stateless/sdks/#account-delegation-sdk-usage
     * @param lsigName name of smart signature (checkpoint info will be stored against this name)
     * @param fileName: Logic Signature filename (must be present in assets folder)
     * @param signer: Signer Account which will sign the smart contract
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    mkDelegatedLsig(lsigName: string, fileName: string, signer: rtypes.Account, scTmplParams?: SCParams): Promise<LsigInfo>;
    /**
     * Stores logic signature info in checkpoint for contract mode
     * @param lsigName name of lsig (checkpoint info will be stored against this name)
     * @param fileName ASC file name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    mkContractLsig(lsigName: string, fileName: string, scTmplParams?: SCParams): Promise<LsigInfo>;
    /**
     * Deploys Algorand Stateful Smart Contract
     * @param payFlags Transaction Params
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * the checkpoint "key", and app information will be associated with this name
     */
    deployApp(creator: Account, appDefinition: wtypes.AppDefinition, payFlags: wtypes.TxParams, scTmplParams?: SCParams): Promise<rtypes.AppInfo>;
    /**
     * Update programs for a contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID ID of the application being configured or empty if creating
     * @param newAppCode new source of application
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param appName name of the app to deploy. This name (if passed) will be used as
     * the checkpoint "key", and app information will be associated with this name
     */
    updateApp(appName: string, sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newAppCode: wtypes.SmartContract, flags: rtypes.AppOptionalFlags, scTmplParams?: SCParams): Promise<rtypes.AppInfo>;
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * executes `ExecParams` or `Transaction` Object, SDK Transaction object passed to this function
     * will be signed and sent to network. User can use SDK functions to create transactions.
     * Note: If passing transaction object a signer/s must be provided.
     * @param transactions transaction parameters or atomic transaction parameters
     * https://github.com/scale-it/algo-builder/blob/docs/docs/guide/execute-transaction.md
     * or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    executeTx(transactions: wtypes.ExecParams[] | wtypes.TransactionAndSign[]): Promise<ConfirmedTxInfo[]>;
}
/**
 * This class is what user interacts with in run task mode
 */
export declare class DeployerRunMode extends DeployerBasicMode implements Deployer {
    get isDeployMode(): boolean;
    persistCP(): void;
    assertNoAsset(name: string): void;
    assertNoLsig(lsigName: string): void;
    assertNoApp(appName: string): void;
    registerASAInfo(name: string, asaInfo: rtypes.ASAInfo): void;
    registerSSCInfo(name: string, sscInfo: rtypes.AppInfo): void;
    logTx(message: string, txConfirmation: ConfirmedTxInfo): void;
    addCheckpointKV(_key: string, _value: string): void;
    deployASA(_name: string, _flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    deployASADef(name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags): Promise<rtypes.ASAInfo>;
    fundLsigByFile(_fileName: string, _flags: FundASCFlags, _payFlags: wtypes.TxParams, _scInitParams?: unknown): Promise<LsigInfo>;
    fundLsig(_lsigName: string, _flags: FundASCFlags, _payFlags: wtypes.TxParams): Promise<LsigInfo>;
    mkDelegatedLsig(_lsigName: string, _fileName: string, _signer: rtypes.Account, _scInitParams?: unknown): Promise<LsigInfo>;
    mkContractLsig(_lsigName: string, _fileName: string, _scInitParams?: unknown): Promise<LsigInfo>;
    deployApp(creator: algosdk.Account, appDefinition: wtypes.AppDefinitionFromFile, payFlags: wtypes.TxParams, scInitParam?: unknown, appName?: string): Promise<rtypes.AppInfo>;
    /**
     * This functions updates SSC in the network.
     * Note: updateApp when ran in RunMode it doesn't store checkpoints
     * @param sender Sender account
     * @param payFlags transaction parameters
     * @param appID application index
     * @param flags SSC optional flags
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    updateApp(appName: string, sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newAppCode: wtypes.SmartContract, flags: rtypes.AppOptionalFlags, scTmplParams?: SCParams): Promise<rtypes.AppInfo>;
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * executes `ExecParams` or `Transaction` Object, SDK Transaction object passed to this function
     * will be signed and sent to network. User can use SDK functions to create transactions.
     * Note: If passing transaction object a signer/s must be provided.
     * @param transactions transaction parameters or atomic transaction parameters
     * https://github.com/scale-it/algo-builder/blob/docs/docs/guide/execute-transaction.md
     * or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    executeTx(transactions: wtypes.ExecParams[] | wtypes.TransactionAndSign[]): Promise<ConfirmedTxInfo[]>;
}
export {};

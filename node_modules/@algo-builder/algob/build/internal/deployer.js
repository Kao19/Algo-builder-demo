"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployerRunMode = exports.DeployerDeployMode = void 0;
const runtime_1 = require("@algo-builder/runtime");
const web_1 = require("@algo-builder/web");
const compile_1 = require("../lib/compile");
const lsig_1 = require("../lib/lsig");
const msig_1 = require("../lib/msig");
const script_checkpoints_1 = require("../lib/script-checkpoints");
const tx_1 = require("../lib/tx");
// Base class for deployer Run Mode (read access) and Deploy Mode (read and write access)
class DeployerBasicMode {
    constructor(deployerCfg) {
        this.runtimeEnv = deployerCfg.runtimeEnv;
        this.cpData = deployerCfg.cpData;
        this.loadedAsaDefs = deployerCfg.asaDefs;
        this.algoOp = deployerCfg.algoOp;
        this.accounts = deployerCfg.runtimeEnv.network.config.accounts;
        this.accountsByName = deployerCfg.accounts;
        this.txWriter = deployerCfg.txWriter;
        this.checkpoint = new script_checkpoints_1.CheckpointFunctionsImpl(deployerCfg.cpData, deployerCfg.runtimeEnv.network.name);
        this.indexerClient = deployerCfg.indexerClient;
    }
    get networkName() {
        return this.runtimeEnv.network.name;
    }
    /**
     * Queries ASA Info from asset name
     * @param name asset name
     */
    getASAInfo(name) {
        const found = this.asa.get(name);
        if (!found) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASA_NOT_DEFINED, {
                assetName: name,
            });
        }
        return found;
    }
    _getAccount(name) {
        const found = this.accountsByName.get(name);
        if (!found) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.ACCOUNT_NOT_FOUND, {
                assetName: name,
            });
        }
        return found;
    }
    /**
     * Returns asset definition for given name
     * @param name Asset name
     * @param asaParams Asa parameters if user wants to override existing asa definition
     */
    getASADef(name, asaParams) {
        return (0, runtime_1.overrideASADef)(this.accountsByName, this.loadedAsaDefs[name], asaParams);
    }
    /**
     * Returns checkpoint metadata
     * @param key key for the map
     */
    getCheckpointKV(key) {
        return this.cpData.getMetadata(this.networkName, key);
    }
    isDefined(name) {
        return this.cpData.isDefined(this.networkName, name);
    }
    get asa() {
        return this.cpData.precedingCP[this.networkName]?.asa ?? new Map();
    }
    get algodClient() {
        return this.algoOp.algodClient;
    }
    async waitForConfirmation(txId) {
        return await this.algoOp.waitForConfirmation(txId);
    }
    /**
     * Queries blockchain using algodv2 for asset information by index
     * @param assetIndex asset index
     * @returns asset info from network
     */
    async getAssetByID(assetIndex) {
        return await this.algoOp.getAssetByID(assetIndex);
    }
    log(msg, obj) {
        this.txWriter.push(msg, obj);
    }
    /**
     * Loads deployed Asset Definition from checkpoint.
     * NOTE: This function returns "deployed" ASADef, as immutable properties
     * of asaDef could be updated during tx execution (eg. update asset clawback)
     * @param asaName asset name in asa.yaml
     */
    loadASADef(asaName) {
        const asaMap = this.cpData.precedingCP[this.networkName]?.asa ?? new Map();
        return asaMap.get(asaName)?.assetDef;
    }
    /**
     * Loads stateful smart contract info from checkpoint
     * @param appName name of the app (defined by user during deployment)
     */
    getApp(appName) {
        return this.assertAppExistsInCP(appName);
    }
    /**
     * Loads logic signature object (contract or delegated) from checkpoint (by lsig name).
     * Panics if the lsig doesn't exists.
     * @param lsigName filename or lsigName (defined by user during mkContractLsig/mkDelegatedLsig)
     */
    getLsig(lsigName) {
        const resultMap = this.cpData.precedingCP[this.networkName]?.dLsig ?? new Map();
        const result = resultMap.get(lsigName)?.lsig;
        if (result === undefined) {
            throw new web_1.BuilderError(web_1.ERRORS.GENERAL.LSIG_NOT_FOUND_IN_CP, {
                lsigName: lsigName,
            });
        }
        const lsigAccount = Object.assign((0, lsig_1.getDummyLsig)(), result);
        lsigAccount.lsig = Object.assign((0, lsig_1.getDummyLsig)().lsig, result.lsig);
        if (lsigAccount.lsig.sig) {
            lsigAccount.lsig.sig = Uint8Array.from(lsigAccount.lsig.sig);
        }
        return lsigAccount;
    }
    /**
     * Loads logic signature for contract mode
     * @param name ASC name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    async loadLogicByFile(name, scTmplParams) {
        return await (0, lsig_1.getLsig)(name, this.algoOp.algodClient, scTmplParams);
    }
    /**
     * Loads logic signature from cache for contract mode. This helps user to avoid
     * passing templaste parameters always during loading logic signature.
     * @param name ASC name
     * @returns loaded logic signature from artifacts/cache/<file_name>.teal.yaml
     * @deprecated this function will be removed in the next release. Use mkContractLsig to
     * store lsig info in checkpoint (against lsigName), and query it in scripts using
     * getLsig
     */
    async loadLogicFromCache(name) {
        return await (0, lsig_1.getLsigFromCache)(name);
    }
    /**
     * Alias to `this.compileASC` with last two parameters being swapped.
     * @deprecated this function will be removed in the next release.
     */
    ensureCompiled(name, force, scTmplParams) {
        return this.compileASC(name, scTmplParams, force);
    }
    /**
     * Returns ASCCache (with compiled code)
     * @param name: Smart Contract filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param force: if force is true file will be compiled for sure, even if it's checkpoint exist
     */
    compileASC(name, scTmplParams, force) {
        return this.algoOp.ensureCompiled(name, "", force, scTmplParams);
    }
    /**
     * Return application in bytes source format
     * @param appName app name
     * @param source
     * @param scTmplParams
     * @returns application in bytes format
     */
    compileApplication(appName, source, scTmplParams) {
        return this.algoOp.compileApplication(appName, source, scTmplParams);
    }
    /**
     * Returns cached program (from artifacts/cache) `ASCCache` object by app/lsig name.
     * @param name App/Lsig name used during deployment
     */
    async getDeployedASC(name) {
        const op = new compile_1.CompileOp(this.algoOp.algodClient);
        // app
        const app = this.getApp(name);
        if (app !== undefined) {
            const approvalCache = await op.readArtifact(app.approvalFile);
            const clearCache = await op.readArtifact(app.clearFile);
            return {
                approval: approvalCache,
                clear: clearCache,
            };
        }
        // lsig
        const resultMap = this.cpData.precedingCP[this.networkName]?.dLsig ?? new Map();
        const lsigInfo = resultMap.get(name);
        if (lsigInfo?.file) {
            return await op.readArtifact(lsigInfo.file);
        }
        return undefined;
    }
    /**
     * Loads multisigned logic signature account from .lsig or .blsig file
     * @param name filename
     * @returns multi signed logic signature from assets/<file_name>.(b)lsig
     */
    async loadMultiSig(name) {
        if (name.endsWith(msig_1.blsigExt)) {
            return await (0, msig_1.loadBinaryLsig)(name);
        }
        const lsig = (await (0, lsig_1.getLsig)(name, this.algoOp.algodClient)).lsig; // get lsig from .teal (getting logic part from lsig)
        const msig = await (0, msig_1.readMsigFromFile)(name); // Get decoded Msig object from .msig
        Object.assign((lsig.msig = {}), msig);
        return lsig;
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    sendAndWait(rawTxns) {
        return this.algoOp.sendAndWait(rawTxns);
    }
    /**
     * Opt-In to ASA for a single account. The opt-in transaction is
     * signed by account secret key
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param accountName
     * @param flags Transaction flags
     */
    optInAccountToASA(asa, accountName, flags) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.OptInASA,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: this._getAccount(accountName),
            assetID: asa,
            payFlags: {},
        });
        let asaId = 0;
        try {
            asaId = this.getASAInfo(asa).assetIndex;
        }
        catch (error) {
            if (!Number(asa)) {
                throw Error("Please provide a valid Number to be used as ASA ID");
            }
            asaId = Number(asa);
        }
        return this.algoOp.optInAccountToASA(asa, asaId, this._getAccount(accountName), flags);
    }
    /**
     * Description: Opt-In to ASA for a contract account (represented by logic signture).
     * The opt-in transaction is signed by the logic signature
     * @param asa ASA (name/ID) Note: ID can be used for assets not existing in checkpoints.
     * @param lsig logic signature
     * @param flags Transaction flags
     */
    optInLsigToASA(asa, lsig, flags) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.OptInASA,
            sign: web_1.types.SignType.LogicSignature,
            fromAccountAddr: lsig.address(),
            lsig: lsig,
            assetID: asa,
            payFlags: {},
        });
        let asaId = 0;
        try {
            asaId = this.getASAInfo(asa).assetIndex;
        }
        catch (error) {
            if (!Number(asa)) {
                throw Error("Please provide a valid Number to be used as ASA ID");
            }
            asaId = Number(asa);
        }
        return this.algoOp.optInLsigToASA(asa, asaId, lsig, flags);
    }
    /**
     * Opt-In to stateful smart contract (SSC) for a single account
     * signed by account secret key
     * @param sender sender account
     * @param appID application index
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInAccountToApp(sender, appID, payFlags, flags) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appID: appID,
            payFlags: {},
        });
        return this.algoOp.optInAccountToApp(sender, appID, payFlags, flags);
    }
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInLsigToApp(appID, lsig, payFlags, flags) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.LogicSignature,
            fromAccountAddr: lsig.address(),
            lsig: lsig,
            appID: appID,
            payFlags: {},
        });
        return this.algoOp.optInLsigToApp(appID, lsig, payFlags, flags);
    }
    /**
     * Asserts ASA is defined in a checkpoint by asset id / string,
     * First: search for ASAInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param asset asset index or asset name
     */
    assertASAExist(asset) {
        let key, res;
        if (typeof asset === "string") {
            res = this.asa.get(asset);
        }
        else if (typeof asset === "number") {
            key = this.checkpoint.getAssetCheckpointKeyFromIndex(asset);
            res = key ? this.asa.get(key) : undefined;
        }
        if (res?.deleted === true) {
            throw new web_1.BuilderError(web_1.ERRORS.GENERAL.ASSET_DELETED, {
                asset: asset,
            });
        }
    }
    /**
     * Asserts App is defined in a checkpoint by app id.
     * First: search for AppInfo in checkpoints
     * Case 1: If it exist check if that info is deleted or not by checking deleted boolean
     * If deleted boolean is true throw error
     * else, pass
     * Case 2: If it doesn't exist, pass
     * @param appID Application index
     */
    assertAppExist(appID) {
        const key = this.checkpoint.getAppCheckpointKeyFromIndex(appID);
        const res = key ? this.checkpoint.getAppfromCPKey(key) : undefined;
        if (res?.deleted) {
            throw new web_1.BuilderError(web_1.ERRORS.GENERAL.APP_DELETED, {
                app: appID,
            });
        }
    }
    /**
     * Group transactions into asa and app, check for cp deletion
     * @param txn Transaction execution parameter
     */
    _assertCpNotDeleted(txn) {
        switch (txn.type) {
            case web_1.types.TransactionType.ModifyAsset:
            case web_1.types.TransactionType.FreezeAsset:
            case web_1.types.TransactionType.RevokeAsset:
            case web_1.types.TransactionType.OptInASA:
            case web_1.types.TransactionType.DestroyAsset: {
                this.assertASAExist(txn.assetID);
                break;
            }
            // https://developer.algorand.org/articles/algos-asas/#opting-in-and-out-of-asas
            // https://developer.algorand.org/docs/reference/transactions/#asset-transfer-transaction
            case web_1.types.TransactionType.TransferAsset: {
                // If transaction is not opt-out check for CP deletion
                if (txn.payFlags.closeRemainderTo === undefined) {
                    this.assertASAExist(txn.assetID);
                }
                break;
            }
            case web_1.types.TransactionType.DeleteApp:
            case web_1.types.TransactionType.CloseApp:
            case web_1.types.TransactionType.OptInToApp:
            case web_1.types.TransactionType.UpdateApp:
            case web_1.types.TransactionType.CallApp: {
                this.assertAppExist(txn.appID);
                break;
            }
        }
    }
    /**
     * Checks if checkpoint is deleted for a particular transaction
     * if checkpoint exist and is marked as deleted,
     * throw error(except for opt-out transactions), else pass
     * @param execParams Transaction execution parameters
     */
    assertCPNotDeleted(execParams) {
        if (Array.isArray(execParams)) {
            for (const txn of execParams) {
                this._assertCpNotDeleted(txn);
            }
        }
        else {
            this._assertCpNotDeleted(execParams);
        }
    }
    /**
     * Throws error if application info is not present in CP
     * @param key key against which app information is stored in checkpoint
     */
    assertAppExistsInCP(key) {
        const app = this.checkpoint.getAppfromCPKey(key);
        if (app === undefined) {
            throw new web_1.BuilderError(web_1.ERRORS.GENERAL.APP_NOT_FOUND_IN_CP, {
                appName: app,
            });
        }
        return app;
    }
    /**
     * Return receipts for each transaction in group txn
     * @param txns list transaction in group
     * @returns confirmed tx info of group
     */
    async getReceiptTxns(txns) {
        return await this.algoOp.getReceiptTxns(txns);
    }
}
/**
 * This class is what user interacts with in deploy task
 */
class DeployerDeployMode extends DeployerBasicMode {
    get isDeployMode() {
        return true;
    }
    addCheckpointKV(key, value) {
        const found = this.cpData.getMetadata(this.networkName, key);
        if (found === value) {
            return;
        }
        if (found) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_METADATA_ALREADY_PRESENT, {
                metadataKey: key,
            });
        }
        this.cpData.putMetadata(this.networkName, key, value);
    }
    /**
     * Asserts if asset is not already present in checkpoint
     * @param name Asset name
     */
    assertNoAsset(name) {
        if (this.isDefined(name)) {
            this.persistCP();
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASSET_ALREADY_PRESENT, {
                assetName: name,
            });
        }
    }
    /**
     * Asserts if lsig is not already present in checkpoint
     * @param lsigName lsig name
     */
    assertNoLsig(lsigName) {
        if (this.isDefined(lsigName)) {
            this.persistCP();
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_LSIG_ALREADY_PRESENT, {
                lsigName: lsigName,
            });
        }
    }
    /**
     * Asserts if app is not already present in checkpoint
     * @param appName app name
     */
    assertNoApp(appName) {
        if (this.isDefined(appName)) {
            this.persistCP();
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_APP_ALREADY_PRESENT, {
                appName: appName,
            });
        }
    }
    /**
     * Persist checkpoint till current call.
     */
    persistCP() {
        (0, script_checkpoints_1.persistCheckpoint)(this.txWriter.scriptName, this.cpData.strippedCP);
    }
    /**
     * Register ASA Info in checkpoints
     */
    registerASAInfo(asaName, asaInfo) {
        this.cpData.registerASA(this.networkName, asaName, asaInfo);
    }
    /**
     * Register SSC Info in checkpoints
     */
    registerSSCInfo(sscName, sscInfo) {
        this.cpData.registerSSC(this.networkName, sscName, sscInfo);
    }
    /**
     * Log transaction with message using txwriter
     */
    logTx(message, txConfirmation) {
        this.txWriter.push(message, txConfirmation);
    }
    /**
     * Creates and deploys ASA using asa.yaml.
     * @name  ASA name - deployer will search for the ASA in the /assets/asa.yaml file
     * @flags  deployment flags
     */
    async deployASA(name, flags, asaParams) {
        const asaDef = (0, runtime_1.overrideASADef)(this.accountsByName, this.loadedAsaDefs[name], asaParams);
        if (asaDef === undefined) {
            this.persistCP();
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASA_DEF_NOT_FOUND, {
                asaName: name,
            });
        }
        return await this.deployASADef(name, asaDef, flags);
    }
    /**
     * Creates and deploys ASA without using asa.yaml.
     * @name ASA name
     * @asaDef ASA definitions
     * @flags deployment flags
     */
    async deployASADef(name, asaDef, flags) {
        this.assertNoAsset(name);
        (0, runtime_1.parseASADef)(asaDef);
        (0, runtime_1.validateOptInAccNames)(this.accountsByName, asaDef);
        let asaInfo = {};
        try {
            asaInfo = await this.algoOp.deployASA(name, asaDef, flags, this.accountsByName, this.txWriter);
        }
        catch (error) {
            this.persistCP();
            console.error(error);
            throw error;
        }
        this.registerASAInfo(name, asaInfo);
        try {
            await this.algoOp.optInToASAMultiple(name, asaDef, flags, this.accountsByName, asaInfo.assetIndex);
        }
        catch (error) {
            this.persistCP();
            console.error(error);
            throw error;
        }
        return asaInfo;
    }
    /**
     * This function will send Algos to ASC account in "Contract Mode"
     * @param fileName     - ASC filename
     * @param flags    - Deployments flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async fundLsigByFile(fileName, flags, payFlags, scTmplParams) {
        try {
            await this.algoOp.fundLsig(fileName, flags, payFlags, this.txWriter, scTmplParams);
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    }
    /**
     * This function will send Algos to ASC account in "Contract Mode". Takes lsig name
     * as input
     * @param lsigName - name of the smart signature (defined by user during mkContractLsig/mkDelegatedLsig)
     * @param flags    - Deployments flags (as per SPEC)
     * @param payFlags - as per SPEC
     */
    async fundLsig(lsigName, flags, payFlags) {
        try {
            const lsig = this.getLsig(lsigName);
            await this.algoOp.fundLsig(lsig, flags, payFlags, this.txWriter);
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    }
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * @param name: Logic Signature filename (must be present in assets folder)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param signer: Signer Account which will sign the smart
     * contract(optional in case of contract account)
     * @param lsigName name of lsig (if passed, checkpoint info will be stored against this name)
     */
    async _mkLsig(fileName, scTmplParams, signer, lsigName) {
        const cpLsigName = lsigName ?? fileName;
        this.assertNoLsig(cpLsigName);
        let lsigInfo = {};
        try {
            const lsig = await (0, lsig_1.getLsig)(fileName, this.algoOp.algodClient, scTmplParams);
            if (signer) {
                lsig.sign(signer.sk);
                lsigInfo = {
                    creator: signer.addr,
                    contractAddress: lsig.address(),
                    lsig: lsig,
                    file: fileName,
                };
            }
            else {
                lsigInfo = {
                    creator: lsig.address(),
                    contractAddress: lsig.address(),
                    lsig: lsig,
                    file: fileName,
                };
            }
        }
        catch (error) {
            this.persistCP();
            console.error(error);
            throw error;
        }
        this.cpData.registerLsig(this.networkName, cpLsigName, lsigInfo);
        return lsigInfo;
    }
    /**
     * Create and sign (using signer's sk) a logic signature for "delegated approval". Then save signed lsig
     * info to checkpoints (in /artifacts)
     * https://developer.algorand.org/docs/features/asc1/stateless/sdks/#account-delegation-sdk-usage
     * @param lsigName name of smart signature (checkpoint info will be stored against this name)
     * @param fileName: Logic Signature filename (must be present in assets folder)
     * @param signer: Signer Account which will sign the smart contract
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    async mkDelegatedLsig(lsigName, fileName, signer, scTmplParams) {
        return await this._mkLsig(fileName, scTmplParams, signer, lsigName);
    }
    /**
     * Stores logic signature info in checkpoint for contract mode
     * @param lsigName name of lsig (checkpoint info will be stored against this name)
     * @param fileName ASC file name
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async mkContractLsig(lsigName, fileName, scTmplParams) {
        return await this._mkLsig(fileName, scTmplParams, undefined, lsigName);
    }
    /**
     * Deploys Algorand Stateful Smart Contract
     * @param payFlags Transaction Params
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * the checkpoint "key", and app information will be associated with this name
     */
    async deployApp(creator, appDefinition, payFlags, scTmplParams) {
        const name = appDefinition.appName;
        this.assertNoApp(name);
        let sscInfo = {};
        try {
            sscInfo = await this.algoOp.deployApp(creator, appDefinition, payFlags, this.txWriter, scTmplParams);
        }
        catch (error) {
            this.persistCP();
            console.error(error);
            throw error;
        }
        this.registerSSCInfo(name, sscInfo);
        return sscInfo;
    }
    /**
     * Update programs for a contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID ID of the application being configured or empty if creating
     * @param newAppCode new source of application
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     * @param appName name of the app to deploy. This name (if passed) will be used as
     * the checkpoint "key", and app information will be associated with this name
     */
    async updateApp(appName, sender, payFlags, appID, newAppCode, flags, scTmplParams) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.UpdateApp,
            sign: web_1.types.SignType.SecretKey,
            appName,
            fromAccount: sender,
            newAppCode,
            appID: appID,
            payFlags: {},
        });
        const cpKey = appName;
        let sscInfo = {};
        try {
            sscInfo = await this.algoOp.updateApp(appName, sender, payFlags, appID, newAppCode, flags, this.txWriter, scTmplParams);
        }
        catch (error) {
            this.persistCP();
            console.error(error);
            throw error;
        }
        this.registerSSCInfo(cpKey, sscInfo);
        return sscInfo;
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * executes `ExecParams` or `Transaction` Object, SDK Transaction object passed to this function
     * will be signed and sent to network. User can use SDK functions to create transactions.
     * Note: If passing transaction object a signer/s must be provided.
     * @param transactions transaction parameters or atomic transaction parameters
     * https://github.com/scale-it/algo-builder/blob/docs/docs/guide/execute-transaction.md
     * or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    async executeTx(transactions) {
        return await (0, tx_1.executeTx)(this, transactions);
    }
}
exports.DeployerDeployMode = DeployerDeployMode;
/**
 * This class is what user interacts with in run task mode
 */
class DeployerRunMode extends DeployerBasicMode {
    get isDeployMode() {
        return false;
    }
    persistCP() {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "persistCP",
        });
    }
    assertNoAsset(name) {
        if (this.isDefined(name)) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_ASSET_ALREADY_PRESENT, {
                assetName: name,
            });
        }
    }
    assertNoLsig(lsigName) {
        if (this.isDefined(lsigName)) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_LSIG_ALREADY_PRESENT, {
                lsigName: lsigName,
            });
        }
    }
    assertNoApp(appName) {
        if (this.isDefined(appName)) {
            throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_APP_ALREADY_PRESENT, {
                appName: appName,
            });
        }
    }
    registerASAInfo(name, asaInfo) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "registerASAInfo",
        });
    }
    registerSSCInfo(name, sscInfo) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "registerSSCInfo",
        });
    }
    logTx(message, txConfirmation) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "logTx",
        });
    }
    addCheckpointKV(_key, _value) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "addCheckpointKV",
        });
    }
    async deployASA(_name, _flags) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "deployASA",
        });
    }
    async deployASADef(name, asaDef, flags) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "deployASADef",
        });
    }
    async fundLsigByFile(_fileName, _flags, _payFlags, _scInitParams) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "fundLsigByFile",
        });
    }
    async fundLsig(_lsigName, _flags, _payFlags) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "fundLsig",
        });
    }
    async mkDelegatedLsig(_lsigName, _fileName, _signer, _scInitParams) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "delegatedLsig",
        });
    }
    async mkContractLsig(_lsigName, _fileName, _scInitParams) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "mkContractLsig",
        });
    }
    async deployApp(creator, appDefinition, payFlags, scInitParam, appName) {
        throw new web_1.BuilderError(web_1.ERRORS.BUILTIN_TASKS.DEPLOYER_EDIT_OUTSIDE_DEPLOY, {
            methodName: "deployApp",
        });
    }
    /**
     * This functions updates SSC in the network.
     * Note: updateApp when ran in RunMode it doesn't store checkpoints
     * @param sender Sender account
     * @param payFlags transaction parameters
     * @param appID application index
     * @param flags SSC optional flags
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    async updateApp(appName, sender, payFlags, appID, newAppCode, flags, scTmplParams) {
        this.assertCPNotDeleted({
            type: web_1.types.TransactionType.UpdateApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appName,
            newAppCode,
            appID: appID,
            payFlags: {},
        });
        return await this.algoOp.updateApp(appName, sender, payFlags, appID, newAppCode, flags, this.txWriter, scTmplParams);
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * executes `ExecParams` or `Transaction` Object, SDK Transaction object passed to this function
     * will be signed and sent to network. User can use SDK functions to create transactions.
     * Note: If passing transaction object a signer/s must be provided.
     * @param transactions transaction parameters or atomic transaction parameters
     * https://github.com/scale-it/algo-builder/blob/docs/docs/guide/execute-transaction.md
     * or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    async executeTx(transactions) {
        return await (0, tx_1.executeTx)(this, transactions);
    }
}
exports.DeployerRunMode = DeployerRunMode;
//# sourceMappingURL=deployer.js.map
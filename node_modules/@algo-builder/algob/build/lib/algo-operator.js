"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoOperatorImpl = exports.createAlgoOperator = exports.ALGORAND_MIN_TX_FEE = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = __importStar(require("algosdk"));
const driver_1 = require("../lib/driver");
const lsig_1 = require("../lib/lsig");
const compile_1 = require("./compile");
const constants_1 = require("./constants");
const tx = __importStar(require("./tx"));
const confirmedRound = "confirmed-round";
// This was not exported in algosdk
exports.ALGORAND_MIN_TX_FEE = 1000;
// Extracted from interaction with Algorand node (100k microAlgos)
const ALGORAND_ASA_OWNERSHIP_COST = 100000;
function createAlgoOperator(network) {
    return new AlgoOperatorImpl((0, driver_1.createClient)(network));
}
exports.createAlgoOperator = createAlgoOperator;
class AlgoOperatorImpl {
    constructor(algocl) {
        this.algodClient = algocl;
        this.compileOp = new compile_1.CompileOp(this.algodClient);
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    async sendAndWait(rawTxns) {
        const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
        return await this.waitForConfirmation(txInfo.txId);
    }
    // Source:
    // https://github.com/algorand/docs/blob/master/examples/assets/v2/javascript/AssetExample.js#L21
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, constants_1.WAIT_ROUNDS);
        if (pendingInfo["pool-error"]) {
            throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
        }
        if (pendingInfo[confirmedRound] !== null && pendingInfo[confirmedRound] > 0) {
            return pendingInfo;
        }
        throw new Error("timeout");
    }
    // Get receipts of group txn
    async getReceiptTxns(txns) {
        const receipts = await Promise.all(txns.map((txn) => {
            return this.algodClient.pendingTransactionInformation(txn.txID()).do();
        }));
        return receipts;
    }
    /**
     * Queries blockchain using algodClient for asset information by index */
    async getAssetByID(assetIndex) {
        return (await this.algodClient.getAssetByID(Number(assetIndex)).do());
    }
    getTxFee(params, txSize) {
        if (params.flatFee) {
            return Math.max(exports.ALGORAND_MIN_TX_FEE, params.fee);
        }
        return Math.max(exports.ALGORAND_MIN_TX_FEE, txSize);
    }
    getUsableAccBalance(accountInfo) {
        // Extracted from interacting with Algorand node:
        // 7 opted-in assets require to have 800000 micro algos (frozen in account).
        // 11 assets require 1200000.
        const assets = accountInfo.assets;
        return (BigInt(accountInfo.amount) -
            BigInt(((assets ?? []).length + 1) * ALGORAND_ASA_OWNERSHIP_COST));
    }
    getOptInTxSize(params, accounts, flags) {
        const randomAccount = accounts.values().next().value;
        // assetID can't be known before ASA creation
        // it shouldn't be easy to find out the latest asset ID
        // In original source code it's uint64:
        // https://github.com/algorand/go-algorand/blob/1424855ad2b5f6755ff3feba7e419ee06f2493da/data/basics/userBalance.go#L278
        const assetID = Number.MAX_SAFE_INTEGER; // not 64 bits but 55 bits should be enough
        const sampleASAOptInTX = tx.makeASAOptInTx(randomAccount.addr, assetID, params, flags);
        const rawSignedTxn = sampleASAOptInTX.signTxn(randomAccount.sk);
        return rawSignedTxn.length;
    }
    async _optInAccountToASA(asaName, assetIndex, account, params, flags) {
        console.log(`ASA ${String(account.name)} opt-in for ASA ${String(asaName)}`);
        const sampleASAOptInTX = tx.makeASAOptInTx(account.addr, assetIndex, params, flags);
        const rawSignedTxn = sampleASAOptInTX.signTxn(account.sk);
        await this.sendAndWait(rawSignedTxn);
    }
    async optInAccountToASA(asaName, assetIndex, account, flags) {
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        await this._optInAccountToASA(asaName, assetIndex, account, txParams, flags);
    }
    async optInLsigToASA(asaName, assetIndex, lsig, flags) {
        console.log(`Contract ${lsig.address()} opt-in for ASA ${asaName}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const optInLsigToASATx = tx.makeASAOptInTx(lsig.address(), assetIndex, txParams, flags);
        const rawLsigSignedTx = algosdk_1.default.signLogicSigTransactionObject(optInLsigToASATx, lsig).blob;
        const txInfo = await this.algodClient.sendRawTransaction(rawLsigSignedTx).do();
        await this.waitForConfirmation(txInfo.txId);
    }
    async optInToASAMultiple(asaName, asaDef, flags, accounts, assetIndex) {
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const optInAccounts = await this.checkBalanceForOptInTx(asaName, txParams, asaDef, accounts, flags.creator, flags);
        for (const account of optInAccounts) {
            await this._optInAccountToASA(asaName, assetIndex, account, txParams, flags);
        }
    }
    async checkBalanceForOptInTx(name, params, asaDef, accounts, creator, flags) {
        if (!asaDef.optInAccNames || asaDef.optInAccNames.length === 0) {
            return [];
        }
        const optInTxFee = this.getTxFee(params, this.getOptInTxSize(params, accounts, flags));
        const optInAccs = [];
        for (const accName of asaDef.optInAccNames) {
            const account = accounts.get(accName);
            if (!account) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_NOT_FOUND, {
                    accountName: accName,
                });
            }
            optInAccs.push(account);
            if (account.addr === creator.addr) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_TRIED_TO_OPT_IN_CREATOR);
            }
            const accountInfo = (await this.algodClient
                .accountInformation(account.addr)
                .do());
            const requiredAmount = optInTxFee + ALGORAND_ASA_OWNERSHIP_COST;
            const usableAmount = this.getUsableAccBalance(accountInfo);
            if (usableAmount < requiredAmount) {
                throw new web_1.BuilderError(web_1.ERRORS.SCRIPT.ASA_OPT_IN_ACCOUNT_INSUFFICIENT_BALANCE, {
                    accountName: accName,
                    balance: usableAmount,
                    requiredBalance: requiredAmount,
                    asaName: name,
                });
            }
        }
        return optInAccs;
    }
    async deployASA(name, asaDef, flags, accounts, txWriter) {
        const message = "Deploying ASA: " + name;
        console.log(message);
        const txParams = await (0, web_1.mkTxParams)(this.algodClient, flags);
        const assetTX = tx.makeAssetCreateTxn(name, asaDef, flags, txParams);
        const rawSignedTxn = assetTX.signTxn(flags.creator.sk);
        const txInfo = await this.algodClient.sendRawTransaction(rawSignedTxn).do();
        const txConfirmation = await this.waitForConfirmation(txInfo.txId);
        const assetIndex = txConfirmation["asset-index"];
        txWriter.push(message, txConfirmation);
        return {
            creator: flags.creator.addr,
            txID: txInfo.txId,
            assetIndex: Number(assetIndex),
            confirmedRound: Number(txConfirmation[confirmedRound]),
            assetDef: asaDef,
            deleted: false,
        };
    }
    /**
     * Sends Algos to ASC account (Contract Account)
     * @param lsig     - Logic Signature (LogicSigAccount or filename with smart contract code)
     * @param flags    - FundASC flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param txWriter - transaction log writer
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async fundLsig(lsig, flags, payFlags, txWriter, scTmplParams) {
        if (typeof lsig === "string") {
            lsig = await (0, lsig_1.getLsig)(lsig, this.algodClient, scTmplParams);
        }
        const contractAddress = lsig.address();
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        let message = "Funding Contract: " + String(contractAddress);
        console.log(message);
        const closeToRemainder = undefined;
        const note = web_1.tx.encodeNote(payFlags.note, payFlags.noteb64);
        const t = algosdk_1.default.makePaymentTxnWithSuggestedParams(flags.funder.addr, contractAddress, flags.fundingMicroAlgo, closeToRemainder, note, params);
        const signedTxn = t.signTxn(flags.funder.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxn = await this.waitForConfirmation(txInfo.txId);
        message = message.concat("\nLsig: " + lsig.address());
        txWriter.push(message, confirmedTxn);
        return {
            creator: flags.funder.addr,
            contractAddress: contractAddress,
            lsig: lsig,
        };
    }
    /**
     * Function to deploy Stateful Smart Contract
     * @param creator Creator of application aka deployer
     * @param appDefinition   Application Definition
     * @param payFlags      TxParams
     * @param txWriter
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    async deployApp(creator, appDefinition, payFlags, txWriter, scTmplParams) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const appProgramBytes = await this.compileApplication(appDefinition.appName, appDefinition, scTmplParams);
        const execParam = {
            type: web_1.types.TransactionType.DeployApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: creator,
            appDefinition: {
                ...appDefinition,
                ...appProgramBytes,
            },
            payFlags: payFlags,
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const txId = txn.txID().toString();
        const signedTxn = txn.signTxn(creator.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxInfo = await this.waitForConfirmation(txId);
        const appId = confirmedTxInfo["application-index"];
        const message = `Signed transaction with txID: ${txId}\nCreated new app-id: ${appId}`; // eslint-disable-line @typescript-eslint/restrict-template-expressions
        console.log(message);
        txWriter.push(message, confirmedTxInfo);
        return {
            creator: creator.addr,
            txID: txInfo.txId,
            confirmedRound: Number(confirmedTxInfo[confirmedRound]),
            appID: Number(appId),
            applicationAccount: (0, algosdk_1.getApplicationAddress)(Number(appId)),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false,
            approvalFile: appDefinition.metaType === web_1.types.MetaType.FILE
                ? appDefinition.approvalProgramFilename
                : `${appDefinition.appName} - approval.teal`,
            clearFile: appDefinition.metaType === web_1.types.MetaType.FILE
                ? appDefinition.clearProgramFilename
                : `${appDefinition.appName} - clear.teal`,
        };
    }
    /**
     * Update programs (approval, clear) for a stateful smart contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID index of the application being configured
     * @param newAppCode new source of application
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param txWriter - transaction log writer
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    async updateApp(appName, sender, payFlags, appID, newAppCode, flags, txWriter, scTmplParams) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const appProgramBytes = await this.compileApplication(appName, newAppCode, scTmplParams);
        const execParam = {
            appName,
            type: web_1.types.TransactionType.UpdateApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appID: appID,
            newAppCode: appProgramBytes,
            payFlags: payFlags,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets,
            appArgs: flags.appArgs,
            note: flags.note,
            lease: flags.lease,
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const txId = txn.txID().toString();
        const signedTxn = txn.signTxn(sender.sk);
        const txInfo = await this.algodClient.sendRawTransaction(signedTxn).do();
        const confirmedTxInfo = await this.waitForConfirmation(txId);
        const message = `Signed transaction with txID: ${txId}\nUpdated app-id: ${appID}`; // eslint-disable-line @typescript-eslint/restrict-template-expressions
        console.log(message);
        txWriter.push(message, confirmedTxInfo);
        return {
            creator: sender.addr,
            txID: txInfo.txId,
            confirmedRound: Number(confirmedTxInfo[confirmedRound]),
            appID: appID,
            applicationAccount: (0, algosdk_1.getApplicationAddress)(appID),
            timestamp: Math.round(+new Date() / 1000),
            deleted: false,
            approvalFile: newAppCode.metaType === web_1.types.MetaType.FILE
                ? newAppCode.approvalProgramFilename
                : `${appName} - approval.teal`,
            clearFile: newAppCode.metaType === web_1.types.MetaType.FILE
                ? newAppCode.clearProgramFilename
                : `${appName} - clear.teal`,
        };
    }
    /**
     * Opt-In to stateful smart contract
     *  - signed by account's secret key
     * @param sender: Account for which opt-in is required
     * @param appID: Application Index: (ID of the application)
     * @param payFlags: Transaction Params
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    async optInAccountToApp(sender, appID, payFlags, flags) {
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const execParam = {
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.SecretKey,
            fromAccount: sender,
            appID: appID,
            payFlags: payFlags,
            appArgs: flags.appArgs,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets,
        };
        const txn = web_1.tx.mkTransaction(execParam, params);
        const signedTxn = txn.signTxn(sender.sk);
        await this.sendAndWait(signedTxn);
    }
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    async optInLsigToApp(appID, lsig, payFlags, flags) {
        console.log(`Contract ${lsig.address()} opt-in for SSC ID ${appID}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
        const params = await (0, web_1.mkTxParams)(this.algodClient, payFlags);
        const execParam = {
            type: web_1.types.TransactionType.OptInToApp,
            sign: web_1.types.SignType.LogicSignature,
            fromAccountAddr: lsig.address(),
            lsig: lsig,
            appID: appID,
            payFlags: payFlags,
            appArgs: flags.appArgs,
            accounts: flags.accounts,
            foreignApps: flags.foreignApps,
            foreignAssets: flags.foreignAssets,
        };
        const optInLsigToAppTx = web_1.tx.mkTransaction(execParam, params);
        const rawLsigSignedTx = algosdk_1.default.signLogicSigTransactionObject(optInLsigToAppTx, lsig).blob;
        await this.sendAndWait(rawLsigSignedTx);
    }
    async ensureCompiled(name, source, force, scTmplParams) {
        return await this.compileOp.ensureCompiled(name, source, force, scTmplParams);
    }
    /**
     * Return application in bytes source format
     * @param appName app name
     * @param source
     * @param scTmplParams
     * @returns application in bytes format
     */
    async compileApplication(appName, source, scTmplParams) {
        // in case of bytes source we do not need to compile it
        if (source.metaType === web_1.types.MetaType.BYTES)
            return source;
        let approvalFile = `${appName} - approval.teal`;
        let clearFile = `${appName} - clear.teal`;
        let approvalSource = "";
        let clearSource = "";
        if (source.metaType === web_1.types.MetaType.FILE) {
            approvalFile = source.approvalProgramFilename;
            clearFile = source.clearProgramFilename;
        }
        if (source.metaType === web_1.types.MetaType.SOURCE_CODE) {
            approvalSource = source.approvalProgramCode;
            clearSource = source.clearProgramCode;
        }
        const app = await this.ensureCompiled(approvalFile, approvalSource, false, scTmplParams);
        const clear = await this.ensureCompiled(clearFile, clearSource, false, scTmplParams);
        // convert to base64 format
        const approvalProgramBytes = new Uint8Array(Buffer.from(app.compiled, "base64"));
        const clearProgramBytes = new Uint8Array(Buffer.from(clear.compiled, "base64"));
        return {
            metaType: web_1.types.MetaType.BYTES,
            approvalProgramBytes,
            clearProgramBytes,
        };
    }
}
exports.AlgoOperatorImpl = AlgoOperatorImpl;
//# sourceMappingURL=algo-operator.js.map
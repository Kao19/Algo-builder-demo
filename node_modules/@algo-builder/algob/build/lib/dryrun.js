"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tealdbg = exports.lsigExt = exports.pyExt = exports.tealExt = void 0;
const runtime_1 = require("@algo-builder/runtime");
const algosdk_1 = require("algosdk");
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const fs_extra_1 = require("fs-extra");
const path = __importStar(require("path"));
const gen_accounts_1 = require("../builtin-tasks/gen-accounts");
const project_structure_1 = require("../internal/core/project-structure");
const time_1 = require("../lib/time");
const tx_1 = require("./tx");
exports.tealExt = ".teal";
exports.pyExt = ".py";
exports.lsigExt = ".lsig";
class Tealdbg {
    constructor(deployer, execParams) {
        this.deployer = deployer;
        this.execParams = execParams;
    }
    /**
     * Create dry run request object using SDK transaction(s) from wtypes.ExecParams
     * User can dump the response (using this.dryRunResponse) or start debugger session
     * @returns SDK dryrun request object
     */
    async createDryRunReq() {
        let signedTxn = (await (0, tx_1.makeAndSignTx)(this.deployer, this.execParams, new Map()))[1];
        if (!Array.isArray(signedTxn)) {
            signedTxn = [signedTxn];
        }
        const signedTxns = [];
        for (const s of signedTxn) {
            const decodedTx = (0, algosdk_1.decodeSignedTransaction)(s);
            signedTxns.push(decodedTx);
        }
        return await (0, algosdk_1.createDryrun)({
            client: this.deployer.algodClient,
            txns: signedTxns,
        });
    }
    /**
     * Gets dryrun response in json from the request object
     * Returns a response with disassembly, logic-sig-messages with PASS/REJECT and sig-trace
     * @param outFile name of file to dump the response. Dumped in `assets/<file>`
     * @param force if true, overwrites an existing dryrun response dump
     */
    async dryRunResponse(outFile, force) {
        const dryRunRequest = await this.createDryRunReq();
        const dryRunResponse = await this.deployer.algodClient.dryrun(dryRunRequest).do();
        if (outFile) {
            const outPath = path.join(project_structure_1.ASSETS_DIR, outFile);
            await (0, gen_accounts_1.writeToFile)(JSON.stringify(dryRunResponse, null, 2), force ?? false, outPath);
        }
        return dryRunResponse;
    }
    /**
     * Start a debugger session using child_process.spawn() using the given args.
     * Kills an existing session first (using killall -9 <process>)
     * @param tealdbgArgs arguments to `tealdbg debug`. Eg. `--mode signature`, `--group-index 0`
     */
    async runDebugger(tealdbgArgs) {
        (0, child_process_1.spawn)(`killall`, ["-9", "tealdbg"]); // kill existing tealdbg process first
        console.log("--> ", tealdbgArgs);
        const childProcess = (0, child_process_1.spawn)(`tealdbg`, ["debug", ...tealdbgArgs], {
            stdio: "inherit",
            cwd: process.cwd(),
        });
        return await new Promise((resolve, reject) => {
            childProcess.once("close", (status) => {
                childProcess.removeAllListeners("error");
                if (status === 0) {
                    resolve(true);
                    return;
                }
                reject(new Error("script process returned non 0 status"));
            });
            childProcess.once("error", (status) => {
                childProcess.removeAllListeners("close");
                reject(new Error("script process returned non 0 status"));
            });
        });
    }
    /**
     * Sets args to pass to `tealdbg debug` command. Currently supported args are
     * tealFile, mode, groupIndex.
     * @param debugCtxParams args passed by user for debugger session
     * @param pathToCache path to --dryrun-dump (msgpack encoded) present in `/cache/dryrun`
     */
    /* eslint-disable sonarjs/cognitive-complexity */
    getTealDbgParams(debugCtxParams, pathToCache) {
        const tealdbgArgs = [];
        /* Push path of tealfile to debug. If not passed then debugger will use assembled code by default
         * Supplying the program will allow debugging the "original source" and not the decompiled version. */
        const file = debugCtxParams.tealFile;
        if (file) {
            let pathToFile;
            if (file.endsWith(exports.pyExt)) {
                let tealFromPyTEAL;
                // note: currently tealdbg only accepts "teal" code, so we need to compile pyTEAL to
                // TEAL first. issue: https://github.com/algorand/go-algorand/issues/2538
                pathToFile = path.join(project_structure_1.CACHE_DIR, "dryrun", path.parse(file).name + "." + (0, time_1.timestampNow)().toString() + exports.tealExt);
                // load pyCache from "artifacts/cache"
                if (fs.existsSync(path.join(project_structure_1.CACHE_DIR, file + ".yaml"))) {
                    const pathToPyCache = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.CACHE_DIR, file + ".yaml");
                    if (pathToPyCache) {
                        const pyCache = (0, runtime_1.loadFromYamlFileSilent)(pathToPyCache);
                        tealFromPyTEAL = pyCache.tealCode;
                    }
                }
                /* Use cached TEAL code if:
                 *  + We already have compiled pyteal code in artifacts/cache
                 *  + template paramteres (scInitParam) are not passed by user
                 * NOTE: if template parameters are passed, recompilation is forced to compile
                 * pyTEAL with the passed params (as the generated TEAL code could differ from cache)
                 */
                if (tealFromPyTEAL !== undefined && debugCtxParams.scInitParam === undefined) {
                    console.info("\x1b[33m%s\x1b[0m", `Using cached TEAL code for ${file}`);
                }
                else {
                    tealFromPyTEAL = (0, runtime_1.getProgram)(file, debugCtxParams.scInitParam);
                }
                this.writeFile(pathToFile, tealFromPyTEAL);
            }
            else {
                pathToFile = (0, runtime_1.getPathFromDirRecursive)(project_structure_1.ASSETS_DIR, file);
            }
            if (pathToFile) {
                tealdbgArgs.push(pathToFile);
            }
        }
        // push path to --dryrun-dump (msgpack encoded) present in `/cache/dryrun`
        tealdbgArgs.push("-d", pathToCache);
        /* Set mode(application/signature) if passed. By default,
         * the debugger scans the program to determine the type of contract. */
        if (debugCtxParams.mode !== undefined) {
            const mode = debugCtxParams.mode === runtime_1.types.ExecutionMode.APPLICATION ? "application" : "signature";
            tealdbgArgs.push("--mode", mode);
        }
        // set groupIndex flag if a transaction group is passed in this.wtypes.ExecParams
        const grpIdx = debugCtxParams.groupIndex;
        if (grpIdx !== undefined) {
            const execParamsArr = Array.isArray(this.execParams)
                ? this.execParams
                : [this.execParams];
            if (grpIdx >= execParamsArr.length) {
                throw new Error(`groupIndex(= ${grpIdx}) exceeds transaction group length(= ${execParamsArr.length})`);
            }
            tealdbgArgs.push("--group-index", grpIdx.toString());
        }
        return tealdbgArgs;
    }
    /**
     * Runs a debugging session:
     *  + Construct dryrun request using wtypes.ExecParams passed by user
     *  + Set arguments for tealdbg debug
     *  + Run debugger session using child_process.spawn()
     * @param debugCtxParams args passed by user for debugger session
     */
    async run(debugCtxParams) {
        // construct encoded dryrun request using SDK
        const dryRunRequest = await this.createDryRunReq();
        /*
            Encoding fails on taking empty arrays ([]), so we need to convert
            to undefined first (hence the type hack). Ideally, the js-sdk type
            for dryrunreq.accounts should be "modelsv2.accounts[] | undefined"
        */
        if (dryRunRequest.accounts.length === 0) {
            dryRunRequest.accounts = undefined;
        }
        if (dryRunRequest.apps.length === 0) {
            dryRunRequest.apps = undefined;
        }
        const encodedReq = (0, algosdk_1.encodeObj)(dryRunRequest.get_obj_for_encoding(true));
        // output the dump in cache/dryrun directory (.msgp file is used as input to teal debugger)
        // similar to 'goal <txns> --dryrun-dump'
        const msgpDumpFileName = "dump-" + (0, time_1.timestampNow)().toString() + ".msgp";
        const pathToCache = path.join(project_structure_1.CACHE_DIR, "dryrun", msgpDumpFileName);
        this.writeFile(pathToCache, encodedReq);
        // run tealdbg debug on dryrun-dump using args
        const tealdbgArgs = this.getTealDbgParams(debugCtxParams ?? {}, pathToCache);
        await this.runDebugger(tealdbgArgs);
    }
    // write (dryrun dump) to file in `cache/dryrun`
    writeFile(filename, content) {
        (0, fs_extra_1.ensureDirSync)(path.dirname(filename));
        fs.writeFileSync(filename, content);
    }
}
exports.Tealdbg = Tealdbg;
//# sourceMappingURL=dryrun.js.map
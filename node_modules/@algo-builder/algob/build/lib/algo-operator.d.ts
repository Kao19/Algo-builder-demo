import { types as rtypes } from "@algo-builder/runtime";
import { types as wtypes } from "@algo-builder/web";
import algosdk, { Account, LogicSigAccount, modelsv2, Transaction } from "algosdk";
import { txWriter } from "../internal/tx-log-writer";
import type { ASCCache, ConfirmedTxInfo, FundASCFlags, LsigInfo, Network, SCParams } from "../types";
import { CompileOp } from "./compile";
export declare const ALGORAND_MIN_TX_FEE = 1000;
export declare function createAlgoOperator(network: Network): AlgoOperator;
export interface AlgoOperator {
    algodClient: algosdk.Algodv2;
    deployASA: (name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags, accounts: rtypes.AccountMap, txWriter: txWriter) => Promise<rtypes.ASAInfo>;
    fundLsig: (lsig: string | LogicSigAccount, flags: FundASCFlags, payFlags: wtypes.TxParams, txWriter: txWriter, scTmplParams?: SCParams) => Promise<LsigInfo>;
    deployApp: (creator: Account, appDefinition: wtypes.AppDefinition, payFlags: wtypes.TxParams, txWriter: txWriter, scTmplParams?: SCParams) => Promise<rtypes.AppInfo>;
    updateApp: (appName: string, sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newAppCode: wtypes.SmartContract, flags: rtypes.AppOptionalFlags, txWriter: txWriter, scTmplParams?: SCParams) => Promise<rtypes.AppInfo>;
    waitForConfirmation: (txId: string) => Promise<ConfirmedTxInfo>;
    getAssetByID: (assetIndex: number | bigint) => Promise<modelsv2.Asset>;
    optInAccountToASA: (asaName: string, assetIndex: number, account: rtypes.Account, params: wtypes.TxParams) => Promise<void>;
    optInLsigToASA: (asaName: string, assetIndex: number, lsig: LogicSigAccount, params: wtypes.TxParams) => Promise<void>;
    optInToASAMultiple: (asaName: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags, accounts: rtypes.AccountMap, assetIndex: number) => Promise<void>;
    optInAccountToApp: (sender: rtypes.Account, appID: number, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags) => Promise<void>;
    optInLsigToApp: (appID: number, lsig: LogicSigAccount, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags) => Promise<void>;
    ensureCompiled: (name: string, source: string, force?: boolean, scTmplParams?: SCParams) => Promise<ASCCache>;
    compileApplication: (appName: string, source: wtypes.SmartContract, scTmplParams?: SCParams) => Promise<wtypes.SourceCompiled>;
    sendAndWait: (rawTxns: Uint8Array | Uint8Array[]) => Promise<ConfirmedTxInfo>;
    getReceiptTxns: (txns: Transaction[]) => Promise<ConfirmedTxInfo[]>;
}
export declare class AlgoOperatorImpl implements AlgoOperator {
    algodClient: algosdk.Algodv2;
    compileOp: CompileOp;
    constructor(algocl: algosdk.Algodv2);
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    sendAndWait(rawTxns: Uint8Array | Uint8Array[]): Promise<ConfirmedTxInfo>;
    waitForConfirmation(txId: string): Promise<ConfirmedTxInfo>;
    getReceiptTxns(txns: Transaction[]): Promise<ConfirmedTxInfo[]>;
    /**
     * Queries blockchain using algodClient for asset information by index */
    getAssetByID(assetIndex: number | bigint): Promise<modelsv2.Asset>;
    getTxFee(params: algosdk.SuggestedParams, txSize: number): number;
    getUsableAccBalance(accountInfo: modelsv2.Account): bigint;
    getOptInTxSize(params: algosdk.SuggestedParams, accounts: rtypes.AccountMap, flags: wtypes.TxParams): number;
    _optInAccountToASA(asaName: string, assetIndex: number, account: rtypes.Account, params: algosdk.SuggestedParams, flags: wtypes.TxParams): Promise<void>;
    optInAccountToASA(asaName: string, assetIndex: number, account: rtypes.Account, flags: wtypes.TxParams): Promise<void>;
    optInLsigToASA(asaName: string, assetIndex: number, lsig: LogicSigAccount, flags: wtypes.TxParams): Promise<void>;
    optInToASAMultiple(asaName: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags, accounts: rtypes.AccountMap, assetIndex: number): Promise<void>;
    checkBalanceForOptInTx(name: string, params: algosdk.SuggestedParams, asaDef: wtypes.ASADef, accounts: rtypes.AccountMap, creator: rtypes.Account, flags: wtypes.TxParams): Promise<rtypes.Account[]>;
    deployASA(name: string, asaDef: wtypes.ASADef, flags: rtypes.ASADeploymentFlags, accounts: rtypes.AccountMap, txWriter: txWriter): Promise<rtypes.ASAInfo>;
    /**
     * Sends Algos to ASC account (Contract Account)
     * @param lsig     - Logic Signature (LogicSigAccount or filename with smart contract code)
     * @param flags    - FundASC flags (as per SPEC)
     * @param payFlags - as per SPEC
     * @param txWriter - transaction log writer
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    fundLsig(lsig: string | LogicSigAccount, flags: FundASCFlags, payFlags: wtypes.TxParams, txWriter: txWriter, scTmplParams?: SCParams): Promise<LsigInfo>;
    /**
     * Function to deploy Stateful Smart Contract
     * @param creator Creator of application aka deployer
     * @param appDefinition   Application Definition
     * @param payFlags      TxParams
     * @param txWriter
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     */
    deployApp(creator: Account, appDefinition: wtypes.AppDefinition, payFlags: wtypes.TxParams, txWriter: txWriter, scTmplParams?: SCParams): Promise<rtypes.AppInfo>;
    /**
     * Update programs (approval, clear) for a stateful smart contract.
     * @param sender Account from which call needs to be made
     * @param payFlags Transaction Flags
     * @param appID index of the application being configured
     * @param newAppCode new source of application
     * @param flags Optional parameters to SSC (accounts, args..)
     * @param txWriter - transaction log writer
     * @param scTmplParams: scTmplParams: Smart contract template parameters
     *     (used only when compiling PyTEAL to TEAL)
     */
    updateApp(appName: string, sender: algosdk.Account, payFlags: wtypes.TxParams, appID: number, newAppCode: wtypes.SmartContract, flags: rtypes.AppOptionalFlags, txWriter: txWriter, scTmplParams?: SCParams): Promise<rtypes.AppInfo>;
    /**
     * Opt-In to stateful smart contract
     *  - signed by account's secret key
     * @param sender: Account for which opt-in is required
     * @param appID: Application Index: (ID of the application)
     * @param payFlags: Transaction Params
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInAccountToApp(sender: rtypes.Account, appID: number, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    /**
     * Opt-In to stateful smart contract (SSC) for a contract account
     * The opt-in transaction is signed by the logic signature
     * @param appID application index
     * @param lsig logic signature
     * @param payFlags Transaction flags
     * @param flags Optional parameters to SSC (accounts, args..)
     */
    optInLsigToApp(appID: number, lsig: LogicSigAccount, payFlags: wtypes.TxParams, flags: rtypes.AppOptionalFlags): Promise<void>;
    ensureCompiled(name: string, source: string, force?: boolean, scTmplParams?: SCParams): Promise<ASCCache>;
    /**
     * Return application in bytes source format
     * @param appName app name
     * @param source
     * @param scTmplParams
     * @returns application in bytes format
     */
    compileApplication(appName: string, source: wtypes.SmartContract, scTmplParams?: SCParams): Promise<wtypes.SourceCompiled>;
}

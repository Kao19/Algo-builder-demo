"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeITxn = exports.calculateFeeCredit = exports.encTxToExecParams = exports.transactionAndSignToExecParams = exports.isEncTxApplicationCall = exports.isEncTxApplicationCreate = exports.isEncTxAssetConfig = exports.isEncTxAssetDeletion = exports.txAppArg = exports.txnSpecByField = exports.checkIfAssetDeletionTx = exports.parseToStackElem = exports.assetTxnFields = void 0;
const web_1 = require("@algo-builder/web");
const algosdk_1 = require("algosdk");
const errors_list_1 = require("../errors/errors-list");
const runtime_errors_1 = require("../errors/runtime-errors");
const constants_1 = require("../lib/constants");
const types_1 = require("../types");
const parsing_1 = require("./parsing");
exports.assetTxnFields = new Set([
    "ConfigAssetTotal",
    "ConfigAssetDecimals",
    "ConfigAssetDefaultFrozen",
    "ConfigAssetUnitName",
    "ConfigAssetName",
    "ConfigAssetURL",
    "ConfigAssetMetadataHash",
    "ConfigAssetManager",
    "ConfigAssetReserve",
    "ConfigAssetFreeze",
    "ConfigAssetClawback",
]);
const globalAndLocalNumTxnFields = new Set([
    "GlobalNumUint",
    "GlobalNumByteSlice",
    "LocalNumUint",
    "LocalNumByteSlice",
]);
// return default value of txField if undefined,
// otherwise return parsed data to interpreter
function parseToStackElem(a, field) {
    if (Buffer.isBuffer(a)) {
        return new Uint8Array(a);
    }
    if (typeof a === "number" || typeof a === "bigint" || typeof a === "boolean") {
        return BigInt(a);
    }
    if (typeof a === "string") {
        return web_1.parsing.stringToBytes(a);
    }
    return constants_1.TxFieldDefaults[field];
}
exports.parseToStackElem = parseToStackElem;
/**
 * Check if given transaction is asset deletion
 * @param txn EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function checkIfAssetDeletionTx(txn) {
    return (String(txn.type) === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.assetIndex > 0 && // assetIndex should not be 0
        !(txn.assetClawback || txn.assetFreeze || txn.assetManager || txn.assetReserve)); // fields should be empty
}
exports.checkIfAssetDeletionTx = checkIfAssetDeletionTx;
/**
 * Description: returns specific transaction field value from tx object
 * @param txField: transaction field
 * @param tx Current transaction
 * @param txns Transaction group
 * @param tealVersion version of TEAL
 */
function txnSpecByField(txField, tx, gtxns, tealVersion) {
    let result; // store raw result, parse and return
    // handle nested encoded obj (for AssetDef, AppGlobalNumFields, AppLocalNumFields)
    if (exports.assetTxnFields.has(txField)) {
        const s = constants_1.TxnFields[tealVersion][txField];
        const assetMetaData = tx.apar;
        result = assetMetaData?.[s];
        return parseToStackElem(result, txField);
    }
    if (globalAndLocalNumTxnFields.has(txField)) {
        const encAppGlobalSchema = txField.includes("Global") ? tx.apgs : tx.apls;
        const s = constants_1.TxnFields[tealVersion][txField];
        result = encAppGlobalSchema?.[s];
        return parseToStackElem(result, txField);
    }
    // handle other cases
    switch (txField) {
        case "FirstValidTime": {
            // Causes program to fail; reserved for future use
            throw new runtime_errors_1.RuntimeError(errors_list_1.RUNTIME_ERRORS.TEAL.REJECTED_BY_LOGIC);
        }
        case "TypeEnum": {
            result = Number(types_1.TxnType[tx.type]); // TxnType['pay']
            break;
        }
        case "TxID": {
            return web_1.parsing.stringToBytes(tx.txID);
        }
        case "GroupIndex": {
            result = gtxns.indexOf(tx);
            break;
        }
        case "NumAppArgs": {
            const appArg = constants_1.TxnFields[tealVersion].ApplicationArgs;
            const appArgs = tx[appArg];
            result = appArgs?.length;
            break;
        }
        case "NumAccounts": {
            const appAcc = constants_1.TxnFields[tealVersion].Accounts;
            const appAccounts = tx[appAcc];
            result = appAccounts?.length;
            break;
        }
        case "NumAssets": {
            const encAppAsset = constants_1.TxnFields[tealVersion].Assets; // 'apas'
            const foreignAssetsArr = tx[encAppAsset];
            result = foreignAssetsArr?.length;
            break;
        }
        case "NumApplications": {
            const encApp = constants_1.TxnFields[tealVersion].Applications; // 'apfa'
            const foreignAppsArr = tx[encApp];
            result = foreignAppsArr?.length;
            break;
        }
        case "AssetSender": {
            /// + for asset_transfer transactions, we use "snd"
            /// + for revoke asset tx (also an asset_transfer) tx, we use "asnd"
            if (tx.type === "axfer") {
                result = tx.asnd ?? tx.snd;
            }
            break;
        }
        default: {
            const s = constants_1.TxnFields[tealVersion][txField]; // eg: rcv = TxnFields["Receiver"]
            result = tx[s]; // pk_buffer = tx['rcv']
        }
    }
    return parseToStackElem(result, txField);
}
exports.txnSpecByField = txnSpecByField;
/**
 * Returns specific transaction field value from array
 * of accounts or application args
 * @param tx current transaction
 * @param txField transaction field
 * @param idx index in EncodedTransaction[txField]
 * @param op Op object
 * @param tealVersion version of TEAL
 * @param line line number in TEAL file
 */
function txAppArg(txField, tx, idx, op, interpreter, line) {
    const tealVersion = interpreter.tealVersion;
    const s = constants_1.TxnFields[tealVersion][txField]; // 'apaa' or 'apat'
    const result = tx[s]; // array of pk buffers (accounts or appArgs)
    if (!result) {
        // handle defaults
        return constants_1.TxFieldDefaults[txField];
    }
    /**
     * handle special case of accounts and applications:
     * + EncTx.Accounts[0] represents sender's account
     * + EncTx.Applications[0] represents current_application_id
     * https://pyteal.readthedocs.io/en/stable/accessing_transaction_field.html#special-case-txn-accounts-and-txn-applications
     */
    if (txField === "Accounts") {
        if (idx === 0) {
            return parseToStackElem(tx.snd, txField);
        }
        idx--; // if not sender, then reduce index by 1
    }
    else if (txField === "Applications") {
        if (idx === 0) {
            return parseToStackElem(tx.apid ?? 0n, txField);
        } // during ssc deploy tx.app_id is 0
        idx--;
    }
    op.checkIndexBound(idx, result, line);
    return parseToStackElem(result[idx], txField);
}
exports.txAppArg = txAppArg;
/**
 * Check if given encoded transaction obj is asset deletion
 * @param txn Encoded EncTx Object
 * Logic:
 * https://developer.algorand.org/docs/reference/transactions/#asset-configuration-transaction
 * https://github.com/algorand/js-algorand-sdk/blob/e07d99a2b6bd91c4c19704f107cfca398aeb9619/src/transaction.ts#L528
 */
function isEncTxAssetDeletion(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid !== undefined &&
        txn.caid !== 0 && // assetIndex should not be 0
        !(txn.apar?.m ?? txn.apar?.r ?? txn.apar?.f ?? txn.apar?.c)); // fields should be empty
}
exports.isEncTxAssetDeletion = isEncTxAssetDeletion;
/**
 * Check if given encoded transaction obj is asset deletion
 * @param txn Encoded EncTx Object
 */
function isEncTxAssetConfig(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.ASSET_CONFIG && // type should be asset config
        txn.caid !== undefined &&
        txn.caid !== 0 && // assetIndex should not be 0
        !isEncTxAssetDeletion(txn)); // AND should not be asset deletion
}
exports.isEncTxAssetConfig = isEncTxAssetConfig;
/**
 * Check if given encoded transaction object is app creation
 * @param txn Encoded EncTx Object
 */
function isEncTxApplicationCreate(txn) {
    return (txn.type === constants_1.TransactionTypeEnum.APPLICATION_CALL &&
        (txn.apan === 0 || txn.apan === undefined) &&
        txn.apid === undefined);
}
exports.isEncTxApplicationCreate = isEncTxApplicationCreate;
/**
 * Check if given encoded transaction object is application call
 * @param txn Encode EncTx Object
 */
function isEncTxApplicationCall(txn) {
    return txn.type === constants_1.TransactionTypeEnum.APPLICATION_CALL && txn.apid !== undefined;
}
exports.isEncTxApplicationCall = isEncTxApplicationCall;
/**
 *
 * @param txAndSign transaction and sign
 * @param ctx context which is tx and sign apply
 * @returns ExecParams object equivalent with txAndSign
 */
function transactionAndSignToExecParams(txAndSign, ctx) {
    const transaction = txAndSign.transaction;
    const encTx = transaction.get_obj_for_encoding();
    // inject approval Program and clear program with string format.
    // TODO: should create function to convert TEAL in Uint8Array to string format?
    encTx.approvalProgram = transaction.approvalProgram;
    encTx.clearProgram = transaction.clearProgram;
    const sign = txAndSign.sign;
    return encTxToExecParams(encTx, sign, ctx);
}
exports.transactionAndSignToExecParams = transactionAndSignToExecParams;
/* eslint-disable sonarjs/cognitive-complexity */
function encTxToExecParams(encTx, sign, ctx, line) {
    const execParams = {
        ...sign,
        payFlags: {},
    };
    execParams.payFlags.totalFee = encTx.fee;
    switch (encTx.type) {
        case constants_1.TransactionTypeEnum.APPLICATION_CALL: {
            if (isEncTxApplicationCreate(encTx)) {
                const appDefinition = {
                    appName: "Mock",
                    metaType: web_1.types.MetaType.FILE,
                    approvalProgramFilename: encTx.approvalProgram,
                    clearProgramFilename: encTx.clearProgram,
                    localInts: encTx.apls?.nui,
                    localBytes: encTx.apls?.nbs,
                    globalInts: encTx.apgs?.nui,
                    globalBytes: encTx.apgs?.nbs,
                };
                execParams.type = web_1.types.TransactionType.DeployApp;
                execParams.appDefinition = appDefinition;
            }
            else if (isEncTxApplicationCall(encTx)) {
                execParams.type = web_1.types.TransactionType.CallApp;
                execParams.appID = encTx.apid;
                execParams.appArgs = encTx.apaa;
            }
            break;
        }
        case constants_1.TransactionTypeEnum.PAYMENT: {
            execParams.type = web_1.types.TransactionType.TransferAlgo;
            execParams.fromAccountAddr = _getAddress(encTx.snd);
            execParams.toAccountAddr =
                getRuntimeAccountAddr(encTx.rcv, ctx, line) ?? constants_1.ZERO_ADDRESS_STR;
            execParams.amountMicroAlgos = encTx.amt ?? 0n;
            if (encTx.close) {
                execParams.payFlags.closeRemainderTo = getRuntimeAccountAddr(encTx.close, ctx, line);
            }
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_FREEZE: {
            execParams.type = web_1.types.TransactionType.FreezeAsset;
            execParams.assetID = encTx.faid;
            execParams.freezeTarget = getRuntimeAccountAddr(encTx.fadd, ctx, line);
            execParams.freezeState = BigInt(encTx.afrz ?? 0n) === 1n;
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_TRANSFER: {
            if (encTx.asnd !== undefined) {
                // if 'AssetSender' is set, it is clawback transaction
                execParams.type = web_1.types.TransactionType.RevokeAsset;
                execParams.recipient = getRuntimeAccountAddr(encTx.arcv, ctx, line) ?? constants_1.ZERO_ADDRESS_STR;
                execParams.revocationTarget = getRuntimeAccountAddr(encTx.asnd, ctx, line);
            }
            else {
                // asset transfer
                execParams.type = web_1.types.TransactionType.TransferAsset;
                execParams.toAccountAddr = getRuntimeAccountAddr(encTx.arcv, ctx) ?? constants_1.ZERO_ADDRESS_STR;
            }
            // set common fields (asset amount, index, closeRemainderTo)
            execParams.amount = encTx.aamt ?? 0n;
            execParams.assetID = encTx.xaid ?? 0;
            // option fields
            if (encTx.aclose) {
                execParams.payFlags.closeRemainderTo = getRuntimeAccountAddr(encTx.aclose, ctx, line);
            }
            if (encTx.rekey) {
                execParams.payFlags.rekeyTo = _getAddress(encTx.rekey);
            }
            break;
        }
        case constants_1.TransactionTypeEnum.ASSET_CONFIG: {
            if (isEncTxAssetDeletion(encTx)) {
                execParams.type = web_1.types.TransactionType.DestroyAsset;
                execParams.assetID = encTx.caid;
            }
            else if (isEncTxAssetConfig(encTx)) {
                // from the docs: all fields must be reset, otherwise they will be cleared
                // https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#asset-configuration
                execParams.type = web_1.types.TransactionType.ModifyAsset;
                execParams.assetID = encTx.caid;
                execParams.fields = {
                    manager: _getASAConfigAddr(encTx.apar?.m),
                    reserve: _getASAConfigAddr(encTx.apar?.r),
                    clawback: _getASAConfigAddr(encTx.apar?.c),
                    freeze: _getASAConfigAddr(encTx.apar?.f),
                };
            }
            else {
                // if not delete or modify, it's ASA deployment
                execParams.type = web_1.types.TransactionType.DeployASA;
                execParams.asaName = encTx.apar?.an;
                execParams.asaDef = {
                    name: encTx.apar?.an,
                    total: Number(encTx.apar?.t),
                    decimals: encTx.apar?.dc !== undefined ? Number(encTx.apar.dc) : 0,
                    defaultFrozen: BigInt(encTx.apar?.df ?? 0n) === 1n,
                    unitName: encTx.apar?.un,
                    url: encTx.apar?.au,
                    metadataHash: encTx.apar?.am ? (0, parsing_1.convertToString)(encTx.apar?.am) : undefined,
                    manager: _getASAConfigAddr(encTx.apar?.m),
                    reserve: _getASAConfigAddr(encTx.apar?.r),
                    clawback: _getASAConfigAddr(encTx.apar?.c),
                    freeze: _getASAConfigAddr(encTx.apar?.f),
                };
            }
            break;
        }
        case constants_1.TransactionTypeEnum.KEY_REGISTRATION: {
            execParams.type = web_1.types.TransactionType.KeyRegistration;
            execParams.voteKey = encTx.votekey?.toString("base64");
            execParams.selectionKey = encTx.selkey?.toString("base64");
            execParams.voteFirst = encTx.votefst;
            execParams.voteLast = encTx.votelst;
            execParams.voteKeyDilution = encTx.votekd;
            break;
        }
        default: {
            // if line is defined => called from ItxnSubmit
            // => throw error with itxn_submit
            if (line) {
                throw new Error(`unsupported type for itxn_submit at line ${line}`);
            }
            else {
                throw new Error("Can't convert encode tx to execParams");
            }
        }
    }
    return execParams;
}
exports.encTxToExecParams = encTxToExecParams;
const _getASAConfigAddr = (addr) => {
    if (addr) {
        return (0, algosdk_1.encodeAddress)(addr);
    }
    return "";
};
const getRuntimeAccount = (publicKey, ctx, line) => {
    if (publicKey === undefined) {
        return undefined;
    }
    const address = (0, algosdk_1.encodeAddress)(Uint8Array.from(publicKey));
    const runtimeAcc = ctx.getAccount(address);
    return runtimeAcc.account;
};
const getRuntimeAccountAddr = (publickey, ctx, line) => {
    return getRuntimeAccount(publickey, ctx, line)?.addr;
};
const _getAddress = (addr) => {
    if (addr) {
        return (0, algosdk_1.encodeAddress)(addr);
    }
    return undefined;
};
/**
 *
 * @param groupTx group transaction
 * @returns remainingFee - fee remaining after execute group Tx
 * 			collected fee - fee collected from group Tx
 * 			required fee - fee require to execute group tx
 */
function calculateFeeCredit(groupTx) {
    let collectedFee = 0;
    for (const tx of groupTx) {
        collectedFee += tx.fee ?? 0;
    }
    const requiredFee = groupTx.length * constants_1.ALGORAND_MIN_TX_FEE;
    return {
        remainingFee: collectedFee - requiredFee,
        collectedFee,
        requiredFee,
    };
}
exports.calculateFeeCredit = calculateFeeCredit;
/**
 * Retunrs field f of the last inner transaction
 * @param op ITxna or ITxn opcode
 * @returns result
 */
function executeITxn(op) {
    const groupTx = op.interpreter.innerTxnGroups[op.interpreter.innerTxnGroups.length - 1];
    const tx = groupTx[groupTx.length - 1];
    let result;
    switch (op.field) {
        case "Logs": {
            const txReceipt = op.interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            const logs = txReceipt?.logs ?? [];
            op.checkIndexBound(op.idx, logs, op.line);
            result = logs[op.idx];
            break;
        }
        case "NumLogs": {
            const txReceipt = op.interpreter.runtime.ctx.state.txReceipts.get(tx.txID);
            const logs = txReceipt?.logs ?? [];
            result = BigInt(logs.length);
            break;
        }
        case "CreatedAssetID": {
            result = BigInt(op.interpreter.runtime.ctx.createdAssetID);
            break;
        }
        case "CreatedApplicationID": {
            result = 0n; // can we create an app in inner-tx?
            break;
        }
        default: {
            result = txnSpecByField(op.field, tx, [tx], op.interpreter.tealVersion);
            if (result === undefined || Object(result).length === 0) {
                result = txAppArg(op.field, tx, op.idx, op, op.interpreter, op.line);
                break;
            }
        }
    }
    return result;
}
exports.executeITxn = executeITxn;
//# sourceMappingURL=txn.js.map
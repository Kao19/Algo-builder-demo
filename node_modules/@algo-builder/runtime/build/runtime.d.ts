import { types } from "@algo-builder/web";
import { Account as AccountSDK, modelsv2 } from "algosdk";
import { AccountStore } from "./account";
import { LogicSigAccount } from "./logicsig";
import { AccountAddress, AccountStoreI, AppInfo, AppOptionalFlags, ASADeploymentFlags, ASAInfo, AssetHoldingM, Context, EncTx, ExecutionMode, RuntimeAccountI, SCParams, SSCAttributesM, StackElem, TxReceipt } from "./types";
export declare class Runtime {
    /**
     * We are using Maps instead of algosdk arrays
     * because of faster and easy querying.
     * This way when querying, instead of traversing the whole object,
     * we can get the value directly from Map
     * Note: Runtime operates on `store`, it doesn't operate on `ctx`.
     */
    private store;
    private _defaultAccounts;
    ctx: Context;
    parentCtx?: Context;
    loadedAssetsDefs: types.ASADefs;
    private round;
    private timestamp;
    constructor(accounts: AccountStoreI[]);
    get defaultBalance(): number;
    /**
     * Returns a list of initialized default accounts created using static accountSDK from account.ts
     *  and funded with default balance (100 ALGO)
     * @returns list of AccountStore
     */
    _setupDefaultAccounts(): AccountStore[];
    /**
     * Resets the state of the default accounts
     */
    resetDefaultAccounts(): void;
    /**
     * Getter for _defaultAccounts, returns a synced version of the accounts list
     * @returns list of AccountStore
     */
    defaultAccounts(): AccountStore[];
    /**
     * Returns transaction receipt for a particular transaction
     * @param txID transaction ID
     */
    getTxReceipt(txID: string): TxReceipt | undefined;
    /**
     * asserts if account is defined.
     * @param address address
     * @param a account
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAccountDefined(address: string, a?: AccountStoreI, line?: number): AccountStoreI;
    /**
     * asserts if account address is defined
     * @param addr account address
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAddressDefined(addr: string | undefined, line?: number): string;
    /**
     * asserts if application exists in state
     * @param app application
     * @param appID application index
     * @param line line number in TEAL file
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAppDefined(appID: number, app?: SSCAttributesM, line?: number): SSCAttributesM;
    /**
     * asserts if asset exists in state
     * @param assetId asset index
     * @param assetDef asset definitions
     * @param line line number
     * Note: if user is accessing this function directly through runtime,
     * the line number is unknown
     */
    assertAssetDefined(assetId: number, assetDef?: modelsv2.AssetParams, line?: number): modelsv2.AssetParams;
    /**
     * Validate first and last rounds of transaction using current round
     * @param gtxns transactions
     */
    validateTxRound(gtxns: EncTx[]): void;
    /**
     * Ensure no duplicate transaction in group txn
     * @param gtxns group transaction
     */
    assertNoDuplicateTransaction(gtxns: EncTx[]): void;
    /**
     * set current round with timestamp for a block
     * @param r current round
     * @param timestamp block's timestamp
     */
    setRoundAndTimestamp(r: number, timestamp: number): void;
    /**
     * Return current round
     */
    getRound(): number;
    /**
     * Return current timestamp
     */
    getTimestamp(): number;
    /**
     * Fetches app from `this.store`
     * @param appID Application Index
     */
    getApp(appID: number): SSCAttributesM;
    /**
     * Fetches account from `this.store`
     * @param address account address
     */
    getAccount(address: string): AccountStoreI;
    /**
     * Fetches global state value for key present in creator's global state
     * for given appID, returns undefined otherwise
     * @param appID: current application id
     * @param key: key to fetch value of from local state
     */
    getGlobalState(appID: number, key: Uint8Array | string): StackElem | undefined;
    /**
     * Fetches local state for account address and application index
     * @param appID application index
     * @param accountAddr address for which local state needs to be retrieved
     * @param key: key to fetch value of from local state
     */
    getLocalState(appID: number, accountAddr: string, key: Uint8Array | string): StackElem | undefined;
    /**
     * Returns asset creator account or throws error is it doesn't exist
     * @param Asset Index
     */
    getAssetAccount(assetId: number): AccountStoreI;
    /**
     * Returns Asset Definitions
     * @param assetId Asset Index
     */
    getAssetDef(assetId: number): modelsv2.AssetParams;
    /**
     * Queries asset id by asset name from global state.
     * Returns undefined if asset is not found.
     * @param name Asset name
     */
    getAssetInfoFromName(name: string): ASAInfo | undefined;
    /**
     * Queries app id by app name from global state.
     * Returns undefined if app is not found.
     * https://www.pivotaltracker.com/story/show/180142720
     * @param approval
     * @param clear
     */
    getAppInfoFromName(approval: string, clear: string): AppInfo | undefined;
    /**
     * Setup initial accounts as {address: SDKAccount}. This should be called only when initializing Runtime.
     * @param accounts: array of account info's
     */
    initializeAccounts(accounts: AccountStoreI[]): void;
    /**
     * Creates new transaction object (tx, gtxs) from given txnParams
     * @param txnParams : Transaction parameters for current txn or txn Group
     * @returns: [current transaction, transaction group]
     */
    createTxnContext(txnParams: types.ExecParams | types.ExecParams[]): [EncTx, EncTx[]];
    mkAssetCreateTx(name: string, flags: ASADeploymentFlags, asaDef: modelsv2.AssetParams): void;
    /**
     * Create Asset in Runtime using asa.yaml
     * @deprecated `deployASA` should be used instead
     * @param asa ASA name
     * @param flags ASA Deployment Flags
     */
    addAsset(asa: string, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Deploy Asset in Runtime using asa.yaml
     * @param asa ASA name
     * @param flags ASA Deployment Flags
     */
    deployASA(asa: string, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Create Asset in Runtime without using asa.yaml
     * @deprecated `deployASADef` should be used instead
     * @param name ASA name
     * @param flags ASA Deployment Flags
     */
    addASADef(asa: string, asaDef: types.ASADef, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Deploy Asset in Runtime without using asa.yaml
     * @param asa ASA name
     * @param flags ASA Deployment Flags
     */
    deployASADef(asa: string, asaDef: types.ASADef, flags: ASADeploymentFlags): ASAInfo;
    /**
     * Opt-In to all accounts given in asa.yaml to a specific asset.
     * @param assetID Asset Index
     * @param accounts list account opt to asa
     */
    optInToASAMultiple(assetID: number, accounts?: string[]): void;
    /**
     * Asset Opt-In for account in Runtime
     * @param assetIndex Asset Index
     * @param address Account address to opt-into asset
     * @param flags Transaction Parameters
     */
    optIntoASA(assetIndex: number, address: AccountAddress, flags: types.TxParams): TxReceipt;
    /**
     * Returns Asset Holding from an account
     * @param assetIndex Asset Index
     * @param address address of account to get holding from
     */
    getAssetHolding(assetIndex: number, address: AccountAddress): AssetHoldingM;
    addCtxAppCreateTxn(creator: AccountSDK, appDef: types.AppDefinition, payFlags: types.TxParams): void;
    /**
     * create new application and returns application id
     * @deprecated `deployApp` should be used instead.
     * @param approvalProgram application approval program
     * @param clearProgram application clear program
     * @param flags SSCDeployment flags
     * @param payFlags Transaction parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     * NOTE - approval and clear program must be the TEAL code as string (not compiled code)
     */
    addApp(approvalProgram: string, clearProgram: string, flags: types.AppDeploymentFlags, payFlags: types.TxParams, debugStack?: number): AppInfo;
    /**
     * deploy a new application and returns application id
     * @param payFlags Transaction parameters
     * @param appDefinition app definition
     * @param scTmplParams Smart Contract template parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    deployApp(sender: AccountSDK, appDefinition: types.AppDefinition, payFlags: types.TxParams, scTmplParams?: SCParams, debugStack?: number): AppInfo;
    addCtxOptInTx(senderAddr: string, appID: number, payFlags: types.TxParams, flags: AppOptionalFlags): void;
    /**
     * Account address opt-in for application Id
     * @param accountAddr Account address
     * @param appID Application Id
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param payFlags Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    optInToApp(accountAddr: string, appID: number, flags: AppOptionalFlags, payFlags: types.TxParams, debugStack?: number): TxReceipt;
    addCtxAppUpdateTx(senderAddr: string, appID: number, payFlags: types.TxParams, flags: AppOptionalFlags): void;
    /**
     * Update application
     * @param appName application Name. Note in runtime application name just placeholder params
     * @param senderAddr sender address
     * @param appID application Id
     * @param newAppCode new application source code
     * @param payFlags Transaction parameters
     * @param flags Stateful smart contract transaction optional parameters (accounts, args..)
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    updateApp(appName: string, senderAddr: string, appID: number, newAppCode: types.SmartContract, payFlags: types.TxParams, flags: AppOptionalFlags, scTmplParams?: SCParams, debugStack?: number): TxReceipt;
    assertMinBalance(amt: bigint, address: string): void;
    /**
     * Validate signature for Algorand account on transaction params.
     * Include check spending account when creating a transaction from Algorand account
     * Throw RuntimeError if signature is invalid.
     * @param txParam transaction parameters.
     */
    validateAccountSignature(txParam: types.ExecParams): void;
    /**
     * Loads logic signature for contract mode, creates a new runtime account
     * associated with lsig
     * @param fileName ASC filename
     * @param scTmplParams: Smart contract template parameters (used only when compiling PyTEAL to TEAL)
     * @param logs only show logs on console when set as true. By default this value is true
     * @returns loaded logic signature from assets/<file_name>.teal
     */
    loadLogic(fileName: string, scTmplParams?: SCParams, logs?: boolean): LogicSigAccount;
    /**
     * Creates a new account with logic signature and smart contract arguments
     * in the runtime store. The arguments are used when we send a transaction with this
     * account and verify it.
     * @param program TEAL code
     * @param args arguments passed
     * @returns logic signature with arguments.
     */
    createLsigAccount(program: string, args: Uint8Array[]): LogicSigAccount;
    /**
     * Transfers `amount` of microAlgos from `from` address to `to` address
     * @param from From account
     * @param to to address
     * @param amount amount of algo in microalgos
     */
    fundLsig(from: RuntimeAccountI, to: AccountAddress, amount: number): TxReceipt;
    /**
     * validate logic signature and teal logic
     * @param txnParam Transaction Parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    validateLsigAndRun(txnParam: types.ExecParams, debugStack?: number): TxReceipt;
    /**
     * This function executes a transaction based on a smart
     * contract logic and updates state afterwards
     * @param txnParams : Transaction parameters
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     */
    executeTx(txnParams: types.ExecParams[] | types.TransactionAndSign[], debugStack?: number): TxReceipt[];
    /**
     * This function executes TEAL code line by line
     * @param program : teal code as string
     * @param executionMode : execution Mode (Stateless or Stateful)
     * @param debugStack: if passed then TEAL Stack is logged to console after
     * each opcode execution (upto depth = debugStack)
     * NOTE: Application mode is only supported in TEALv > 1
     */
    run(program: string, executionMode: ExecutionMode, indexInGroup: number, debugStack?: number): TxReceipt;
}

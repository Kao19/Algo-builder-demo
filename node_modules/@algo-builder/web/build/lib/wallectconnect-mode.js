"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WallectConnectSession = void 0;
const utils_1 = require("@json-rpc-tools/utils");
const client_1 = __importDefault(require("@walletconnect/client"));
const algorand_walletconnect_qrcode_modal_1 = __importDefault(require("algorand-walletconnect-qrcode-modal"));
const algosdk_1 = __importDefault(require("algosdk"));
const types_1 = require("../types");
const api_1 = require("./api");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
class WallectConnectSession {
    constructor(walletURL, connector) {
        this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);
        if (connector) {
            this.connector = connector;
        }
        else {
            // create new session
            this.connector = new client_1.default({
                bridge: "https://bridge.walletconnect.org",
                qrcodeModal: algorand_walletconnect_qrcode_modal_1.default,
            });
        }
        // if connection not already established, log message to create one
        if (!this.connector.connected) {
            (0, logger_1.warn)(`Connection not established, please use "this.create()" to create new session`);
        }
        this.wcAccounts = this.connector.accounts;
    }
    /**
     * Create new session
     * @param force if true, kills an existing session and creates new one.
     * By default force is false
     */
    async create(force = false) {
        if (this.connector.connected) {
            if (force) {
                try {
                    await this.close();
                }
                catch (e) {
                    (0, logger_1.error)("Can't close walletconnect connection", e);
                }
            }
            else {
                (0, logger_1.warn)(`A session is already active`);
                return;
            }
        }
        await this.connector.createSession();
    }
    /**
     * Close Connection
     */
    async close() {
        await this.connector.killSession();
    }
    /**
     * On connect subscription event
     * @param handler handler callback
     */
    onConnect(handler) {
        this.connector.on("connect", (err, payload) => {
            const { peerId, peerMeta, accounts } = payload.params[0];
            this.wcAccounts = accounts;
            handler(err, { peerId, peerMeta, accounts });
        });
    }
    /**
     * onUpdate subscription event
     * @param handler handler callback
     */
    onUpdate(handler) {
        this.connector.on("session_update", (err, payload) => {
            const { accounts } = payload.params[0];
            this.wcAccounts = accounts;
            handler(err, { accounts });
        });
    }
    /**
     * onDisconnect subscription event
     * @param handler handler callback
     */
    onDisconnect(handler) {
        this.connector.on("disconnect", (err, payload) => {
            const { message } = payload.params[0];
            handler(err, { message });
        });
    }
    /**
     * Sign a single transaction from a wallect connect session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @param message optional message with txn
     * @returns raw signed txn
     */
    async signTransaction(txn, message) {
        const txnInGroup = {
            txn,
            shouldSign: true,
        };
        const response = await this.signTransactionGroup([txnInGroup], message);
        if (response[0] == null) {
            throw new Error("Transaction was returned unsigned");
        }
        return response[0];
    }
    /**
     * Sign a group of transaction(s) from a wallect connect session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @param message optional message with txn
     * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed
     * by wallet user (i.e signable by someone else).
     * TODO: handle case of multiple signers in group transaction
     */
    async signTransactionGroup(txns, message) {
        const walletTxns = txns.map((txn) => {
            const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn.txn)).toString("base64");
            let signers;
            if (txn.shouldSign) {
                if (Array.isArray(txn.signers)) {
                    signers = txn.signers;
                }
                else if (txn.signers) {
                    signers = [txn.signers];
                }
                else {
                    signers = undefined;
                }
            }
            else {
                signers = [];
            }
            return {
                signers,
                txn: encodedTxn,
                message: txn.message,
                msig: txn.msig,
            };
        });
        const requestParams = [walletTxns];
        (0, logger_1.log)("requestParams ", requestParams);
        if (message) {
            requestParams.push({ message });
        }
        const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);
        const result = await this.connector.sendCustomRequest(request);
        return result.map((element) => {
            return element ? new Uint8Array(Buffer.from(element, "base64")) : null;
        });
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    async sendAndWait(rawTxns) {
        const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
        return await this.waitForConfirmation(txInfo.txId);
    }
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, constants_1.WAIT_ROUNDS);
        if (pendingInfo["pool-error"]) {
            throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
        }
        return pendingInfo;
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * @param transactions transaction parameters,  atomic transaction parameters
     *  or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    async executeTx(transactions) {
        let signedTxn;
        let txns = [];
        if (transactions.length > 16) {
            throw new Error("Maximum size of an atomic transfer group is 16");
        }
        if (!(0, types_1.isSDKTransactionAndSign)(transactions[0])) {
            const execParams = transactions;
            for (const [_, txn] of execParams.entries()) {
                txns.push((0, txn_1.mkTransaction)(txn, await (0, api_1.mkTxParams)(this.algodClient, txn.payFlags)));
            }
        }
        txns = algosdk_1.default.assignGroupID(txns);
        const toBeSignedTxns = txns.map((txn) => {
            return { txn: txn, shouldSign: true };
        });
        signedTxn = await this.signTransactionGroup(toBeSignedTxns);
        // remove null values from signed txns array
        // TODO: replace null values with "externally" signed txns, otherwise
        // signedtxns with nulls will always fail!
        signedTxn = signedTxn.filter((stxn) => stxn);
        const confirmedTx = await this.sendAndWait(signedTxn);
        (0, logger_1.log)("confirmedTx: ", confirmedTx);
        return confirmedTx;
    }
    /** @deprecated */
    async executeTransaction(execParams) {
        if (Array.isArray(execParams))
            return this.executeTx(execParams);
        else
            return this.executeTx([execParams]);
    }
}
exports.WallectConnectSession = WallectConnectSession;
//# sourceMappingURL=wallectconnect-mode.js.map
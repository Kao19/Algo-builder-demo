"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebMode = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const errors_1 = require("../errors/errors");
const types_1 = require("../types");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
const CONFIRMED_ROUND = "confirmed-round";
const LAST_ROUND = "last-round";
class WebMode {
    constructor(algoSigner, chainName) {
        this.algoSigner = algoSigner;
        this.chainName = chainName;
    }
    /**
     * wait for confirmation for transaction using transaction id
     * @param txId Transaction id
     */
    async waitForConfirmation(txId) {
        const response = await this.algoSigner.algod({
            ledger: this.chainName,
            path: "/v2/status",
        });
        (0, logger_1.log)(response);
        const startRound = response[LAST_ROUND];
        let currentRound = startRound;
        // eslint-disable-next-line no-constant-condition
        while (currentRound < startRound + constants_1.WAIT_ROUNDS) {
            const pendingInfo = await this.algoSigner.algod({
                ledger: this.chainName,
                path: `/v2/transactions/pending/${txId}`,
            });
            if (pendingInfo[CONFIRMED_ROUND] !== null &&
                pendingInfo[CONFIRMED_ROUND] > 0) {
                return pendingInfo;
            }
            // TODO: maybe we should use "sleep" instead of pinging a node again?
            currentRound += 1;
            await this.algoSigner.algod({
                ledger: this.chainName,
                path: `/v2/status/wait-for-block-after/${currentRound}`, // eslint-disable-line @typescript-eslint/restrict-template-expressions
            });
        }
        throw new Error(`Transaction not confirmed after ${constants_1.WAIT_ROUNDS} rounds`);
    }
    /**
     * Send transaction to network
     * @param signedTxn signed transaction
     */
    async sendTransaction(signedTxn) {
        return await this.algoSigner.send({
            ledger: this.chainName,
            tx: signedTxn.blob,
        });
    }
    /**
     * Send group transaction to network
     * @param signedTxs signed transaction group
     */
    async sendGroupTransaction(signedTxs) {
        // The AlgoSigner.signTxn() response would look like '[{ txID, blob }, null]'
        // Convert first transaction to binary from the response
        const signedTxBinary = signedTxs.map((txn) => {
            return this.algoSigner.encoding.base64ToMsgpack(txn.blob);
        });
        // Merge transaction binaries into a single Uint8Array
        const flatNumberArray = signedTxBinary.reduce((acc, curr) => {
            acc.push(...curr);
            return acc;
        }, []);
        const combinedBinaryTxns = new Uint8Array(flatNumberArray);
        // Convert the combined array values back to base64
        const combinedBase64Txns = this.algoSigner.encoding.msgpackToBase64(combinedBinaryTxns);
        return await this.algoSigner.send({
            ledger: this.chainName,
            tx: combinedBase64Txns,
        });
    }
    /**
     * Sign transaction using algosigner
     * @param txns Array of transactions in base64
     */
    async signTransaction(txns) {
        return await this.algoSigner.signTxn(txns);
    }
    /**
     * Returns suggested transaction parameters using algosigner
     * @param userParams Transaction parameters
     */
    async getSuggestedParams(userParams) {
        const txParams = await this.algoSigner.algod({
            ledger: this.chainName,
            path: "/v2/transactions/params",
        });
        const s = {
            fee: txParams.fee,
            genesisHash: txParams["genesis-hash"],
            genesisID: txParams["genesis-id"],
            firstRound: txParams[LAST_ROUND],
            lastRound: Number(txParams[LAST_ROUND]) + 1000,
            flatFee: false,
        };
        s.flatFee = userParams.totalFee !== undefined;
        s.fee = userParams.totalFee || userParams.feePerByte || txParams["min-fee"]; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
        if (s.flatFee)
            s.fee = Math.max(Number(s.fee), Number(txParams["min-fee"]));
        s.firstRound = userParams.firstValid || s.firstRound; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
        s.lastRound =
            userParams.firstValid === undefined || userParams.validRounds === undefined // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing
                ? s.lastRound
                : Number(userParams.firstValid) + Number(userParams.validRounds);
        return s;
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * @param transactions transaction parameters, atomic transaction parameters
     * or TransactionAndSign object(SDK transaction object and signer parameters)
     */
    async executeTx(transactions) {
        let txns = [];
        if (transactions.length > 16 || transactions.length == 0) {
            throw new errors_1.BuilderError(errors_1.ERRORS.GENERAL.TRANSACTION_LENGTH_ERROR, {
                length: transactions.length,
            });
        }
        if ((0, types_1.isSDKTransactionAndSign)(transactions[0]))
            throw new Error("We don't support this case now");
        const execParams = transactions;
        for (const [_, txn] of execParams.entries()) {
            txns.push((0, txn_1.mkTransaction)(txn, await this.getSuggestedParams(txn.payFlags)));
        }
        txns = algosdk_1.default.assignGroupID(txns);
        const binaryTxs = txns.map((txn) => {
            return txn.toByte();
        });
        const base64Txs = binaryTxs.map((txn) => {
            return this.algoSigner.encoding.msgpackToBase64(txn);
        });
        // with logic signature we don't need signers.
        const toBeSignedTxns = base64Txs.map((txn, txnId) => {
            return execParams[txnId].sign === types_1.SignType.LogicSignature
                ? { txn: txn, signers: [] }
                : { txn: txn };
        });
        const signedTxn = await this.signTransaction(toBeSignedTxns);
        // sign smart signature transaction
        for (const [txnId, txn] of txns.entries()) {
            const singer = execParams[txnId];
            if (singer.sign === types_1.SignType.LogicSignature) {
                singer.lsig.lsig.args = singer.args ?? [];
                const lsigTxn = algosdk_1.default.signLogicSigTransaction(txn, singer.lsig);
                signedTxn[txnId] = {
                    blob: this.algoSigner.encoding.msgpackToBase64(lsigTxn.blob),
                    txId: lsigTxn.txID,
                };
            }
        }
        const txInfo = await this.sendGroupTransaction(signedTxn);
        if (txInfo && typeof txInfo.txId === "string") {
            return await this.waitForConfirmation(txInfo.txId);
        }
        throw new Error("Transaction Error");
    }
    /** @deprecated */
    async executeTransaction(execParams) {
        if (Array.isArray(execParams))
            return this.executeTx(execParams);
        else
            return this.executeTx([execParams]);
    }
}
exports.WebMode = WebMode;
//# sourceMappingURL=web-mode.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MyAlgoWalletSession = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const __1 = require("..");
const api_1 = require("./api");
const constants_1 = require("./constants");
const logger_1 = require("./logger");
const txn_1 = require("./txn");
class MyAlgoWalletSession {
    constructor(walletURL, connector) {
        this.accounts = [];
        this.addresses = [];
        this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);
        try {
            const MyAlgoConnect = require("@randlabs/myalgo-connect"); // eslint-disable-line @typescript-eslint/no-var-requires
            if (connector) {
                this.connector = connector;
            }
            else {
                this.connector = new MyAlgoConnect();
            }
        }
        catch (err) {
            (0, logger_1.error)(err);
        }
    }
    // https://connect.myalgo.com/docs/interactive-examples/Connect
    async connectToMyAlgo() {
        try {
            this.accounts = await this.connector.connect({
                shouldSelectOneAccount: true,
                openManager: true,
            });
            this.addresses = this.accounts.map((account) => account.address);
        }
        catch (err) {
            throw new Error("Error while connecting to MyAlgo Wallet");
        }
    }
    /**
     * https://connect.myalgo.com/docs/interactive-examples/PaymentTransaction
     * Sign a single transaction from a my algo wallet session
     * @param txn { SDK transaction object, shouldSign, signers, msig } object
     * @returns raw signed txn
     */
    async signTransaction(txn) {
        return await this.connector.signTransaction(txn.toByte());
    }
    /**
     * https://connect.myalgo.com/docs/interactive-examples/GroupedTransaction
     * Sign a group of transaction(s) from a my algo wallet session
     * @param txns { SDK transaction object, shouldSign, signers, msig } object
     * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed
     * by wallet user (i.e signable by someone else).
     */
    async signTransactionGroup(txns) {
        const txnsGroup = txns.map((v) => v.txn);
        const groupID = algosdk_1.default.computeGroupID(txnsGroup);
        for (let i = 0; i < txns.length; i++)
            txnsGroup[i].group = groupID;
        return await this.connector.signTransaction(txnsGroup.map((txn) => txn.toByte()));
    }
    /**
     * Send signed transaction to network and wait for confirmation
     * @param rawTxns Signed Transaction(s)
     */
    async sendAndWait(rawTxns) {
        const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();
        return await this.waitForConfirmation(txInfo.txId);
    }
    // Function used to wait for a tx confirmation
    async waitForConfirmation(txId) {
        const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, constants_1.WAIT_ROUNDS);
        if (pendingInfo["pool-error"]) {
            throw new Error(`Transaction Pool Error: ${pendingInfo["pool-error"]}`);
        }
        return pendingInfo;
    }
    /**
     * Execute single transaction or group of transactions (atomic transaction)
     * @param execParams transaction parameters or atomic transaction parameters
     */
    async executeTx(execParams) {
        let signedTxn;
        let txns = [];
        if (execParams.length > 16) {
            throw new Error("Maximum size of an atomic transfer group is 16");
        }
        for (const [_, txn] of execParams.entries()) {
            txns.push((0, txn_1.mkTransaction)(txn, await (0, __1.mkTxParams)(this.algodClient, txn.payFlags)));
        }
        txns = algosdk_1.default.assignGroupID(txns);
        const toBeSignedTxns = txns.map((txn) => {
            return { txn: txn, shouldSign: true };
        });
        signedTxn = await this.signTransactionGroup(toBeSignedTxns);
        signedTxn = signedTxn.filter((stxn) => stxn);
        const Uint8ArraySignedTx = signedTxn.map((stxn) => stxn.blob);
        const confirmedTx = await this.sendAndWait(Uint8ArraySignedTx);
        (0, logger_1.log)("confirmedTx: ", confirmedTx);
        return confirmedTx;
    }
    /** @deprecated */
    async executeTransaction(execParams) {
        if (Array.isArray(execParams))
            return this.executeTx(execParams);
        else
            return this.executeTx([execParams]);
    }
}
exports.MyAlgoWalletSession = MyAlgoWalletSession;
//# sourceMappingURL=myalgowallet-mode.js.map